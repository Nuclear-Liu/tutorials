# 

## 高并发


OSI 七层参考模型

> 分层解耦


应用层 <=> 表示层 <=> 会话层 <=> 传输控制层 <=> 网络层 <=> 链路层 <=> 物理层


* 应用层： 应用软件、 Tomcat、浏览器；与人交互或后台运行提供服务。
* 表示层： 协议、语义、加密
* 会话层： 会话保持，Session
* 传输层： 传输控制
* 网络层： 数据路由、传输，
* 链路层： 点对点通信控制
* 物理成： 传输媒介，硬件


TCP/IP 协议

应用层 <=> 传输控制层 <=> 网络层 <=> 链路层 <=> 物理层


* 应用层： 端点

    HTTP SSH SMTP

* 传输控制层： 三次握手

    TCP 面向连接，可靠传输 UDP 无连接，不可靠传输 Socket

    * 创建连接：三次握手 完成创建网络连接资源
  
        从方向和 IO 两个层次角度解释
        
        * 方向，第一次请求连接，发起方发送 syn（发起方进入 SYN_SEND 状态等待被链接方确认），第二次响应连接 被链接方发送 syn+ack （发起方接收确认连接建立进入 SYN_RECV 状态，服务方还没有完成连接确认），第三次确认响应 发送方发送确认响应 ACK （发送方与被连接方进入 ESTABLISHED ）。

    * 断开链接：四次挥手 释放资源
  
        Socket (一台机器可以有65535个端口资源)
        
        * 第一次 请求断开方发送断开连接请求，第二次 被链接方确认收到断开连接请求，第三次 被链接方发送断开连接请求，第四次 请求断开方确认被链接方的断开请求。 双方销毁资源

    > 三次握手 -->> 数据传输 -->> 四次挥手
    > 
    > 通过三次握手与四次挥手来回的数据包互相确认把系统资源的创建和销毁的过程叫做面向连接。
    > 
    > 三次握手创建连接、数据传输和四次挥手断开链接称为一个最小粒度，不可被分割。

* 网络层： 下一跳

    网络使用下一跳机制：当前主机一步之内的网络信息（包括网关）路由表（`route -n ）通过路由判定（按位与）

    IP 点分字节 

* 链路层： 节点 (`arp -a`)

    arp 协议：发送ARP协议（目标 Mac 地址是全 `F` 目标 IP 为网关，源 Mac 源 IP ）会被广播，广播到网关，会回复给发送ARP协议的主机

    交换机会学习 mac 地址和网络端口 的关系

* 物理层：


> TCP/IP 协议：基于下一跳的机制，IP是端点间，Mac地址是节点间的

> 传输控制层一下 基本上属于内核空间。


## NAT ：基于**三层到四层**的解决方案


> NAT 网络地址转换
>
> 一般位于路由器中，由一张表记录请求的请求的端口和请求IP与NAT生成的随机端口的表，修改数据包的源地址和源端口  属于 **S-NAT** 源地址转换


加一个基于四层的**负载均衡器**，但是负载均衡器不会和请求进行握手建立链接，速度快，进行数据包级别的转发。


通过传修改输层数据包的目标端口号和目标 IP 到达负载目标。 属于 **D-NAT** 目标地址转换协议


请求数据包 通过 D-NAT 转换转发请求数据包


### 缺点

* 被负载服务器的默认网关必须是负载均衡器。
* 要求被负载的对象彼此之间是镜像的。
* 带宽称为瓶颈。在通信的时候是非对称的，下行带宽是瓶颈。
* 消耗算力。


## DR (直接路由模式) ：基于**二层**的 Mac 地址欺骗  _企业中心应用最多_

被负载对象服务器对真是IP进行隐藏，对外隐层对内可见。
请求经过负载均衡器进入被负载对象，处理后直接返回给客户端，响应不在经过负载均衡器。链路形成环状。

* 速度快
* 成本低

### 缺点

* 负载均衡器必须与被负载的机器位于同一个网络内。

## TUN (隧道模式)


TUN 隧道技术： IP 的数据包背着 IP 的数据包的技术


## LVS (Linux Virtual Server) Linux 虚拟服务器：四层技术


不会增加单一吞吐量，而是将并发分治。


### 隐藏 VIP (虚拟IP)


通过修改 kernel 内核的网络协议实现。


> Kernel parameter
> 
> 目标 mac 地址为全 `F` ，交换机触发广播 `/proc/sys/net/ipv4/conf/*IF*/arp_ignore` 定义接收到 ARP 请求时的响应级别：
> `0` : 只要本地配置的有相应地址，就给予响应； 
> `1` : 仅在请求的目标 (MAC) 地址配置请求到达的接口上的时候，才给予响应；
> 
> `/proc/sys/net/ipv4/conf/*IF*/arp_announce` 定义将自己地址向外通知时的通告级别：
> `0` : 将本地任何接口上的任何地址向外通告；
> `1` : 试图仅向目标网络通告与其网络匹配的地址；
> `2` : 仅向与本地接口上地址匹配的网络进行通告；


> 一个网卡可以有多个IP地址

1. 修改内核 ARP 配置参数；
2. 把 VIP 配置到内核虚拟网卡上（回环接口 LOOPBACK ）；

### 调度算法

#### 静态调度算法

1. `rr` 轮询
2. `wrr`
3. `dh`
4. `sh`

#### 动态调度算法

1. `lc` 最少链接数

    链接数的获取：负载均衡器具备偷窥能力；
    记录客户端握手请求中的 ip + port （三次握手确定链接确认） 链接数 +1 
    记录经过的数据包的断开链接的请求 确定断开 链接数 -1

2. `wlc` 加权最小连接
3. `sed` 最短期望延迟
4. `np` never queue
5. `LBLC` 基于本地的最少连接
6. `DH`
7. `LBLCR` 基于本地的带复制功能的最小连接


### 实现 LVS

LVS 包裹在 Linux Kernel 中 模块的名称为 `ipvs` 默认带有。

`ipvsadm` 为与内核 `ipvs` 交互的包，实现与 `ipvs` 交互。

`yum install ipvsadm -y`

* 管理集群服务 入

  * 添加 `-A` `-A -t|u|f service-address [-s scheduler]`

    * `t` TCP 协议集群
    * `u` UDP 协议集群
    * 'f' FWM 防火墙标记
    * `service-address` ip + port
    * `s` 调度算法

  * 修改 `-E`

  * 删除 `-D`

  `ipvsadm -A -t 192.168.9.100:80 -s rr`

* 管理集群服务中的 RS 出

  * 添加 `-a` `-a -t|u|f service-address -r server-address [-g|i|m] [-w weight]`
  
    * `-t|u|f service-address` 事先定义好的某集群服务
    * `-r server-address` 某 RS 的地址，在 NAT 模型中，可使用 ip + port 实现端口映射
    * `[-g|i|m]` LVS 类型
      * `-g` DR
      * `-i` TUN
      * `-m` NAT
    * `[-w weight]` 定义服务器权重
  * 修改 `-e`
  * 删除 `-d` `-d -t|u|f service-address -r server-address`
  
    `ipvsadm -a -t 172.16.100.1:80 -r 192.168.10.8 -g`
  
    `ipvsadm -a -t 172.16.100.1:80 -r 192.168.10.9 -g`

  * 查看 `-L|l` `L` 查看集群服务； `l` 查看集群中 RS
    * `-n` 数字格式显示主机地址和端口
    * `--status` 统计数据
    * `--rate` 速率
    * `--timeout` 显示 TCP TCPFIN UDP 的会话超时时长
    * `-c` 显示当前的 `ipvs` 连接状况
  * 删除所有集群服务 `-C` 清空 `ipvs` 规则
  * 保存规则 `-S` 
  
    `ipvsadm -S > /path/to/somefile`
  
  * 载入此前的规则 `-R`
  
    `ipvsadm -R < /path/form/somefile`


#### 实验手册

VM 提供虚拟网络

VM 提供虚拟主机

VIP: `192.168.150.100`
DIP(LVS): `192.168.150.1`
RIP:

**LVS 实验手册**
```shell
# node01:LVS config
ifconfig eth0:8 192.168.150.100/24

# node02~node03: config
# 1. edit ARP 
echo 1 > /proc/sys/net/ipv4/conf/eth0/arp_ignore
echo 1 > /proc/sys/net/ipv4/conf/all/arp_ignore

echo 2 > /proc/sys/net/ipv4/conf/eth0/arp_announce
echo 2 > /proc/sys/net/ipv4/conf/all/arp_announce
# 2. set VIP
ifconfig lo:3 192.168.150.100 netmask 255.255.255.255

# RS(node02~node03) 中配置对应服务
yum install httpd -y
service httpd start
vi /var/www/html/index.html # insert text `from 192.168.150.1x`

# node01 LVS config
yum install ipvsadm
ipvsadm -A -t 192.168.150.100:80 -s rr
ipvsadm -ln
ipvsadm -a -t 192.168.150.100:80 -r 192.168.150.12 -g -w 1
ipvsadm -ln
ipvsadm -a -t 192.168.150.100:80 -r 192.168.150.13 -g -w 1

# node01 lvs 
netstat -natp # can not find socket connection
# node02 RS
netstat -natp # can find socket connection
# node03 RS
netstat -natp # can find socket connection

# node01 lvs
ipvsadm -lnc
#    FIN_WAIT 连接过，偷窥了所有包
#    SYN_RECV 基本上 LVS 都记录了，证明 LVS 正常，一定是与负载间的网络层出问题了
```





















