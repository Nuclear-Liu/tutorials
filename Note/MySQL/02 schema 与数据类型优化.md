# Schema 与数据类型优化


## 数据类型的优化


### 更小的通常更好


尽量使用可以正确存储数据的**最小数据类型**，更小的数据类型通常更快，因为占用更少的磁盘、内存和 CPU 缓存，并且处理时需要的 CPU 周期更少；


> InnoDB:
> 
> `*.frm` : 存储表结构文件；
>
> `*.ibd` : 存储表数据文件（数据和索引）；
> 
> MyISAM:
> 
> `*.frm` : 存储表结构文件； 
> 
> `*.MYD` : 存储表数据文件；
> 
> `*.MYI` : 存储数据索引文件；


### 简单就好


**简单数据类型**的操作通常需要更少的 CPU 周期（速度）（和磁盘空间）；例如：

1. 整形比字符串操作代价更低；字符串校验规则是字符串比较整形比较更加复杂；
2. 使用 MySQL 自建类型而不是字符串类存储日期和时间；
3. 用整形存储 IP 地址；
  
  * `inet_aton(ip_address_string)` : 将 IP 点分字符串地址串转成 int 数值
  * `inet_ntoa(ip_adress_value)` : 将 IP int值地址转成点分字符串


### 尽量避免 `null`


在数据库中 `null != null` ；


如果查询中包含可能为 `null` 的列，对 MySQL 来说很难优化，因为可为 `null` 的列使的索引、索引统计和值比较都更加复杂；


通常情况下 `null` 的列改为 `not null` 带来的性能提升比较小，但事实应该尽量避免设计成为 `null` 的列；


### 实际细则


#### 整数类型

> 尽量使用满足需求的最小数据类型；

* `tinyint`: `1byte`
* `smallint`: `2byte`
* `mediumint`: `3byte`
* `int`: `4byte`
* `bigint`: `8byte`

#### 字符和字符串类型


* `varchar` 根据实际内容长度保存数据（可变长度）

  1. 使用最小的符合需求的长度；
  2. `varchar(n)` `n` 小于等于 `255` 使用额外的一个字节保存长度， `n > 255` 使用额外的两个自己保存长度；
  3. 相同记录长度字节范围内，硬盘占用空间一样，内存占用空间不同，长度越小，占用的内存越少（ `varchar(5) 与 varchar(255)` ）；
  4. `varchar` 在 MySQL 5.6 之前变更长度会导致锁表；后期版本不会导致锁表；

  **应用场景：**
    * 存储**长度波动较大**的数据（如：文章，有的会很短有的会很长）；
    * 字符串**很少更新**的场景，每次更新后都会重算并使用额外的存储空间保存长度；
    * 适合保存多字节字符（如汉字，特殊字符等）；

* `char` 固定长度字符串

  1. 最大长度： `255` ；
  2. 自动删除末尾的空格；
  3. 检索效率、写效率会比 `varchar` **高**（以空间换时间）；

  **应用场景：**
    * 存储**长度波动不大**的数据（ md5 摘要）；
    * 存储**短**字符串、**经常更新**的字符串；

#### `text` 与 `blob`

> `text` `blob` 一般不用；

* `text` 将值作为一个对象存储，采用**字符串方式**存储

* `blob` 将值作为一个对象存储，采用**二进制方式**村粗

#### `datetime` `timestamp` `date`


* `datetime`

  > 不要使用**字符串**存储日期类型，占用空间大，损失日期型函数的便捷性；

  1. 占用 `8` 个字符；
  2. 与**时区无关**，数据库底层时区配置，对 `datetime` 无效；
  3. 精确到 `ms` ；
  4. 可保存时间范围大；

* `timestamp` 实际中使用比较多

  1. 占用 `4` 字节；
  2. 时间范围 `[1970-01-01, 2038-01-19]` ；
  3. 精确到 `s` ；
  4. 采用整形存储（实际存储的是到当前时间的 `s` 值；
  5. 依赖数据库设置的时区；
  6. 自动更新 `timestamp` 列的值；

* `date`

  1. 占用 `3` 字节；
  2. 使用 `date` 类型可以利用日期函数进行日期间的计算；
  3. 精确到 `d` ；
  4. 时间范围 `[0000-01-01, 9999-12-31]` ；

> `timestamp` 实际使用比较多，空间与精度的折中；
> 
> 
> 时区的问题：不同时区导致与时区相关的时间的时间戳会不同；


#### 使用**枚举类型**替代**字符串类型**

> 使用枚举类代替常用的字符串类型；
> 
> MySQL 存储枚举类型会非常紧凑，根据列表值的数据压缩到一个或两个字节中；
> 在内部将每个值在列表中的位置保存为**整数**，并且在表的 `*frm` (表结构文件)文件中保存 **数字-字符串** 映射关系；
> 
> 支持排序，排序是根据枚举底层值有关；
> 
> 条件查询支持枚举值查询和底层存储整型值两种方式；

```sql
create table enum_table (
    e enum('enum_value_1', 'enum_value_2') not null
);
```

#### 特殊类型数据

对于 IP 地址本质上是 `32 bite` 无符号整数，而不是字符串；
利用 `int` 类型的时候可以利用提供的函数进行 IP 转换；

## 合理使用范式和反范式

表设计的**三范式**的目的是为了减少数据冗余；

### 范式

> 第一范式： 用来确保每列的原子性，要求每列（或者每个属性值）都是不可再分的最小数据单元（也称为最小的原子单元）；
> 
> 第二范式： 在第一范式的基础上，要求表中的每列都和主键**相关**，即要求实体的唯一性；
> 
> 第三范式： 在第二范式的基础上，确保每列都和主键列**直接相关**，而不是间接相关，即**限制列的冗余性**；

**优点：**
* 范式化的更新通常比反范式要快；

* 当数据较好的范式化后；

* 范式化的数据比较小，可以放在内存中，操作比较快；

**缺点：**
* 通常需要进行**关联**；

### 反范式

**优点：**
* 所有的数据在同一张表中，可以避免关联；

* 可以设计有效的索引；

**缺点：**
* 表格内冗余较多，删除数据时候会造成表有些有用的信息丢失

### 注意

在企业中很少能做到严格意义上的范式或者反范式，一般需要混合使用；

> 一个网站实例中，允许用户发送消息，并且一些用户是**付费用户**。
> 现在想查看付费用户最近的 `10` 条信息。
> 在 `user` 表和 `message` 表中都存储**用户类型**（`account_type`）而不用完全的范式化。
> 避免了完全范式化的插入和删除问题，因为即使没有消息的时候也不会丢失用户信息。
> 不会把 `user_message` 表搞得太大，有利于高效地获取数据；
> 
> 另一个从**父表**冗余一些数据到**子表**的理由是**排序**的需要；
> 全排序的情况下，需要所有内存进入内存，通过将相关数据放入一张表中，或者通过索引进行排序（索引使用 B+ 树，有序）。
> （使用索引查询的情况下 `limit` 后就不需要 `order by` ）；
> 
> 缓存衍生值也是有用的，如果需要显示每个用户发了多少消息（类似于论坛），可以每次执行一个昂贵的自查询表计算并显示它。
> 也可以在 `user` 表中建一个 `num_messages` 列，每当用户发消息时更新这个值。


## 主键的选择

### 代理主键

与业务无关，无意义的数字序列；

### 自然主键

事物属性中的自然唯一标识；

### 推荐使用**代理主键**

1. 不与业务耦合，更加容易维护；
2. 一个大多数表，最好是全部表，通用的键策略能够减少需要编写的源码数量，减少系统的总体拥有成本；

> 主键生成器 自定义生成策略；

## 字符集的选择

> `UTF-8` `man utf-8`
> 
> MySQL 中只能存储两个字符的中文，建议使用 `utf8-mb4`

1. 纯拉丁文字符能表示的内容，没必要选择 `latin1` 之外的其它字符编码，因为可以节省存储空间；
2. 如果可以确定不需要存放多种语言，就没必要一定使用 `UTF-8` 或者其他 `UNICODE` 字符类型，这回造成大量存储空间浪费；
3. MySQL 的数据类型可以精确到字段，所以当我们需要大型数据库中存放多字节数据的时候，可以通过对不同表不同字段使用不同的数据类型来减少数据存储量，进而降低 I/O 操作次数并提高缓存命中率；

## 存储引擎的选择


| 比较项    | MyISAM      | InnoDB                        |
|--------|-------------|-------------------------------|
| 索引类型   | 非聚簇索引       | 聚簇索引                          |
| 支持事务   | 否           | 是                             |
| 支持表锁   | 是           | 是                             |
| 支持行锁   | 否           | 是                             |
| 支持外键   | 否           | 是                             |
| 支持全文索引 | 是           | 是（ 5.6 后支持）                   |
| 适合操作类型 | 大量 `select` | 大量 `insert` `delete` `update` |


> 非聚簇索引 vs 聚簇索引
> 
> **数据文件**与**索引文件**是否在一起；


## 适当的数据冗余

被频繁引用且只能通过 `join` 多张其他大表的方式才能得到的独立小字段；
由于每次 `join` 仅仅只是为了取得某个小字段的值， `join` 到的记录又大，会造成大量不必要的 IO ；
可以通过空间换取时间的方式来优化，不过冗余的同时需要确保数据的一致性不会遭到破坏，确保更新的同时冗余字段也被更新。

## 适当拆分

> 数据库表拆分：
> 
> * 垂直拆分：按照业务进行拆分
> 
> * 水平拆分： 数据分片

当表中存在类似于 `text` 或者是很大的 `varchar` 类型的大字段的时候；
如果我们大部分访问这张表的时候不需要访问这些字段，可以将其拆分成独立的表，以减少常用数据所占用的存储空间。

这样的好处是每个数据块可以存储的数据条数可以大大增加，既减少了物理 IO 次数，也能大大提高内存中的缓存命中率；
