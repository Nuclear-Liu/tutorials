# 通过索引进行优化


> 底层实现使用的是 B+Tree 。
> 
> 选择 B+Tree 的原因：
>
> Hash 表索引缺点(InnoDB, MyISAM)：
> 1. 利用 Hash 存储的话**需要将所有的数据文件加载到内存**，耗费内存空间；
> 2. 如果所有的查询都是**等值查询非常快**，如果是**范围查找数据效率低**（ Hash 表需要遍历整体）；
> 
> 二叉树 (BS-Tree)：
> 
> 数据插入的时候会造成树本身的倾斜，树深度增加，增大系统 IO （每次获取节点都是一次 IO ）；
> 
> 平衡树 (AVL-Tree)
> 
> 为了保证树的平衡，需要进行旋转操作，保证最短子树与最长子树高度差不能超过 `1` （插入删除效率低，查询效率高）。
> 
> 红黑树 (RadBlack-Tree)
> 
> 是 AVL-Tree 的一种，最长子树只要不超过最短子树的两倍即可，通过旋转和变色（变色减少旋转操作）的功能实现插入性能与查询性能达到平衡
> （因为只有两个分支，最终还是会因为节点过深导致 IO 的次数过多）；
> 
> * 左旋：逆时针旋转，将根节点的右节点的左节点给根节点当作右节点，根节点成为右节点的左节点。
> 
> * 右旋：顺时针旋转，将根节点的左节点的右节点给根节点当作左节点，根节点当作右节点的右节点。
> 
> B Tree
> 
> 可以又多个分支。索引节点带有数据，可以支持区间查询，如果命中缓存则直接读取节点下的数据。
> 缺点：索引节点带上了数据信息；导致索引支持的数据索引空间变小。
> 
> B+Tree
> 
> 在 B Tree 的基础上进行优化，让索引的非叶子节点不在携带数据信息，只存储 key 值和指针值；叶子节点直接放置数据，索引的覆盖空间增大。
> 叶子节点又双向指针串联，支持顺序数据各个数据块中的数据。
> 
> B*Tree
> 
> 在 B+Tree 的基础上，在非叶子节点间构建双向指针；
> 
> **非节点叶子节点没有存储数据，所以没有 MySQL 中没有选择 B*Tree**


在 `InnoDB` 和 `MyISAM` 中索引默认都是 B+Tree ；
但是存储数据的格式不一样（导致查找最终数据节点的时候方式不同）：

* `InnoDB` 数据与索引单一文件存储；

  叶子节点中实际存储对应的一整行的数据；

* `MyISAM` 数据与索引单独文件存储；

  叶子节点存放的不是实际的数据，存放的是数据所在数据文件的位置信息；

> **注意：**
> 
> 1. `InnoDB` 是通过 B+Tree 结构对主键创建索引，然后叶子节点中存储记录；如果没有主键，会选择**唯一键**；如果没有**唯一键**，会选择生成一个 `6bite` 的 `row_id` 作为主键；
> 2. 如果创建索引的键是其他字段，**在叶子节点中存储的是该记录的主键**，然后在通过主键索引找到对应的记录，这个过程叫做**回表**；

## 索引基本知识

### 索引的优点


1. 减少服务器扫描的数据量（ IO 量）；
2. 帮助服务器避免**排序**和**临时表**；

  最好不要使用**文件排序**(`explain` 的 `extra` 是： `using filesort`)，尽量使用**索引排序**；

3. 将随机 IO 变成顺序 IO ；


### 索引的用处


1. 快速查找匹配的 `WHERE` 子句的行；

2. 从 `consideration` 中消除行，**如果可以在多个索引之间进行选择， MySQL 通常会使用找到最少行的索引**；

3. 如果表具有多列索引，则优化器可以使用索引的任何最左前缀的来查找行；

4. 当有表连接的时候，从其他表检索行数据；

5. 查找特定索引列的 `min` 或 `max` 值；

6. 如果排序或分组是在可用索引的**最左前缀**上完成的，则对表进行**排序**和**分组**；

7. 在某些情况下，可以优化查询以检索值而无需查询数据行；


### 索引的分类


> 数据库会默认为**唯一键**建索引（所有唯一键，不仅限于主键）；


* 主键索引

* 唯一索引

* 普通索引

* 全文索引

* 组合索引


### 面试技术名词


* 回表

  在 InnoDB 中默认为主键创建索引，当为普通列创建索引时，叶子节点存放的是**主键**，当查询的时候需要再次根据主键索引查询实际的数据行信息，这个过程叫做**回表**；

* 覆盖索引

  如果一个索引包含了（覆盖了）查询语句中的字段或条件就叫做覆盖索引 (`explain` 的 `extra` 是： `using index`) （比如索引中查询主键 id 的情形，在普通索引中已经存在，不需要回表过程，所以叫做覆盖索引）；

* 最左匹配（仅限于组合索引）

  多个列创建索引（组合索引），当查询条件语句忽略了使用最左侧的列而是用了其他列，当前的查询不能使用当前的索引；

* 索引下推

  （前提条件是组合索引，组合索引满足最左匹配，但是遇到非等值判断时匹配停止）当条件中出现索引内容的条件的时候，在索引数据的阶段对数据进行过滤，省略到数据到数据库 server 层的时候的判断计算（降低了 IO 量）；

* 索引合并

  高版本支持索引合并，但是效率不一定高；

> 谓词下推
> 
> `select t1.name, t2.name from ti join t2 on ti.id = t2.id;`
> 
> 根据id 对 t1 t2 进行关联，然后取出需要的字段；
> 
> 先把 t1.id t1.name t2.id t2.name 取出，然后进行关联；
> 
> 谓词(动词)


### 索引匹配方式


* 全值匹配(type: `ref`)

  全值匹配指（条件）的是和索引中的所有列进行匹配；

  `explain select * from staffs where name = 'July' and age = 23 and pos = 'dev';`

* 匹配最左前缀(type: `ref`)

  只匹配前面的几列；

  `explain select * from staffs where name = 'July' and age = 25;`

* 匹配列前缀(`using index condition`, type: `range`)

  可以匹配某一列的值的开头部分；

  `explain select * from staffs where name like 'J%';`

  `explain select * from staffs where name like '%y';`

* 匹配范围值(`using index condition`, type: `range`)

  可以查找某一个范围的数据；

  `explain select * from staffs where name > 'Mary';`

* 精确匹配某一列并范围匹配另一列(`using index condition`, type: `range`, ref: `null`)

  可以查询第一列的全部和第二列的部分；

  `explain select * from staffs where name = 'July' and age > 35;`

* 只访问索引查询(`using index`, type: `ref`, ref: `const`)

  查询的时候只需要访问索引，不需要访问数据行，本质上是**覆盖索引**；

  `explain select name, age, pos from staffs where name = 'July' and age = 25 and pos = 'dev';`


## 哈希索引


在 MySQL 中，只有 `memory` 的存储引擎显式支持哈希索引；
基于哈希表的实现，只有**精确匹配索引所有列**的查询才有效；


> 哈希索引只需要存储对应的 hash 值，所以索引的结构十分紧凑，这让哈希索引查找的速度非常快；


### 哈希索引的限制


1. 哈希索引只包含哈希值和**行指针**，而不存储字段值，索引不能使用索引中的值来避免读取行；
2. 哈希索引数据并不是按照索引顺序存储的，所以**无法进行排序**；
3. 哈希索引**不支持部分列匹配查找**，哈希索引是使用索引列的全部内容来计算哈希值；
4. 哈希表支持等值比较查询，**不支持任何范围查询**；
5. 访问哈希表索引的数据非常快，除非有很多哈希冲突，当出现哈希冲突的时候，存储引擎必须遍历链表中的所有行指针，逐行进行比较。直到所有符合条件的行；
6. 哈希冲突如果比较多，维护代价增大；


### 案例


当需要存储大量的 URL ，并且根据 URL 进行搜索查找，如果使用 B+Tree ，存储的内容就会很大： `select id from url where url = '';` ；
可以将 URL 使用 `CRC32` 算法做哈希，可以使用一下查询： `select id from url where url = '' and url_crc = CRC32('url');` ;
利用体积小的 `CRC32` 索引来完成查询；


## 组合索引


当包含多个列作为索引，需要注意的是争取的顺序依赖于该索引的查询，同时需要考虑如何更好的满足**排序**和**分组**的需要（索引的顺序）；


> 创建索引考虑的问题；
> 
> * 索引顺序
> * 索引大小

## 聚簇索引与非聚簇索引


### 聚簇索引 (InnoDB)


不是单独的索引类型，而是一种**数据存储方式**，指的是**数据行跟相邻的键值紧凑的存储在一起**；


#### 优点


1. 可以把相关数据保存在一起；
2. 数据访问更**快**，因为索引和数据保存在同一个树中；
3. 使用**覆盖索引**扫描的查询可以直接使用页节点中的主键值；


#### 缺点


1. 聚簇索引数据量大限度地**提高 IO 密集型应用的性能**，如果数据全部在内存，那么聚簇索引就没有什么优势；
2. 插入速度严重依赖于**插入顺**序，按照主键的**顺序插入是最快的方式**；

  B+Tree 每个叶子节点存储的数据大小是一定的，如果页节点没有足够的空间会涉及到**页分裂**的过程

3. **更新聚簇索引列**的代价很高，因为会强制将每个被更新的行移动到新的位置；
4. 基于聚簇索引的表的插入新行，或者主键被更新导致需要移动数据行的时候，可能面临**页分裂**的问题；
5. 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于**页分裂**导致数据存储不连续的时候；


> **页分裂**
> 
> 将原有的数据页分裂为两个数据页（一般是因为主键插入，导致原有也空间不能存放新数据，页按照要插入的位置分裂为前后两个新的页节点）；
> 
> **页合并**
> 
> 将两个数据页进行合并（一般是由于数据删除导致页节点所在空间不在有数据信息，导致页的合并）；


在移动迁移数据时，可以先把创建索引关闭，数据迁移完成后再把索引打开创建索引属性打开；


### 非聚簇索引 (MyISAM)


数据文件跟索引文件分开存放；


## 覆盖索引


* 如果一个索引包含所有需要查询的字段的值，称之为**覆盖索引**；
* 不是所有类型的索引都可以称为**覆盖索引**，覆盖索引必须**存储列的值**；
* 不同的存储实现覆盖索引的方式不同，不是所有的引擎都支持覆盖索引（ `memory` 不支持覆盖索引）；


extra: `using index`


### 优势


1. 索引条目
