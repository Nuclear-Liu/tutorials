# 查询优化


## 查询慢的原因


1. 网络
2. CPU
3. IO
4. 上下文切换
5. 系统调用
6. 生成统计信息

    数据库性能等的收集信息；

7. 锁等待时间

    锁与存储引擎相关：
    * `MyISAM` 中锁类型： **共享读锁**，**独占写锁**；只能**锁表**；

    * `InnoDB` 中锁类型： **共享锁**，**排它锁**；可以**锁表**、**锁行**；锁的对象是**索引**，如果锁的列是索引列对应为**行锁**，如果没有索引，会从**行锁**退化成**表锁**；

> **自增锁**：
> **间隙锁**：

## 优化数据访问


1. 查询性能低下的主要原因是访问的数据太多，某些查询不可避免的需要筛选大量的数据，可以通过减少访问数据量的方式进行优化（IO）；

    1. 确定应用程序是否在检索大量超过需要的数据；
    
        `explain select * from rental limit 10000, 5;` 通过子查询提高查询效率；
   
    2. 确认 MySQL 服务器层是否在分析大量超过需要的数据行；

2. 是否数据库请求了不需要的数据；

    1. 查询不需要的记录

        通常误以为 MySQL 会只返回需要的数据，实际上 MySQL 是先返回全部结果在进行计算，在日常开发中经常用 `select` 查询大量结果，然后获取前面的 `N` 行；优化方式：**在查询后面添加 `limit`**
   
    2. 多表关联时返回全部列
    3. 总是取出全部列
    4. 重复查询相同的数据
    

## 执行过程的优化


1. 查询缓存 (MySQL 8.x 不再支持)

    在解析一个查询语句之前，如果查询缓存是打开的， MySQL 会优先检查查询是否命中查询缓存中的数据，如果查询命中缓存，会在返回结果之前检查用户权限，如果权限允许， MySQL 跳过所有阶段，直接从缓存中拿到结果并返回给客户端；

2. 查询优化处理

    查询缓存之后会经过几个步骤：解析 SQL、预处理、优化 SQL 执行计划；

    1. 语法解析器和预处理器
   
        MySQL 通过关键字将 SQL 语句进行解析，并生成一颗**解析树**(Abstract Syntax Tree) ；
        MySQL 解析器进行语法规则验证和解析查询；
        预处理器进一步检查**解析树**是否合法（表名、列明是否存在，验证权限）；
   
    2. 查询优化
   
        语法树没有问题后，由优化器将其转换成执行计划，一条查询语句可以使用非常多的执行方式（查询计划）得到相同的对应结果，但是不同执行方式效率不同，优化器主要目的就是**选择最优的执行计划**；

        MySQL 使用**基于成本的优化器**；
        在优化的时候尝试预测查询不同查询计划的成本，选择其中成本最小查询计划；

        * `select count(*) from film_actor;` `show status like 'last_query_cost';` 可以看到查询语句花费的成本（通过一系列的统计信息计算得出）；统计信息：
            * 每个表或索引的页面个数；
            * 索引的**基数**；
            * 索引和数据行的长度；
            * 索引的分布情况；
        * 在很多情况下 MySQL 会选择错误的执行计划，原因：
            * 统计信息不准确；
            * 执行计划的成本估计不等于实际执行的成本；
            * MySQL 的最优可能与设想不一致（成本优化不一定是最快的优化）；
            * MySQL 不考虑其他并发执行的查询；
            * MySQL 不会考虑**不受其控制的操作成本**（执行存储过程或者用户自定义函数的成本）；
        * 优化器的优化策略
            
            MySQL 对查询的静态优化只需要一次，对动态优化在每次执行时都需要重新评估；
       
            * 静态优化：直接对解析树进行分析，完成优化；
            * 动态优化：动态优化与查询的上下文有关，可能跟取值、索引对应行数有关；
        * 优化器的优化类型
       
            * 重新定义关联表的顺序
            * 将外连接转换成为内连接，内连接的效率高于外连接
            * 使用等价变化规则，简化并规划表达式
            * 优化 `count()` `min()` `max()`
            
                索引和列是否可以为空通常可以帮助 MySQL 优化这类表达式；
                例如：要找到某一列的最小值，只需要查询索引的最左前缀的记录即可，不需要全文扫描比较；
          
            * 预估并转化为常熟表达式，当 MySQL 检测到一个表达式可以转化为常数的时候，就会一直把该表达式作为常数进行处理
            * 索引覆盖扫描，当索引中的列包含所有查询中需要使用的列的时候，可以使用覆盖索引
            * 子查询优化
            
                MySQL 在某些情况下可以将子查询转换为一种效率更高的形式，从而减少多个查询多次对数据进行访问（例如将经常查询的数据放入缓存中）；
          
            * 等值传播
          
                如果两个列的值通过等式关联，那么 MySQL 能够把其中一个列的 `where` 条件传递到另一个上；
                
                `explain select film.film_id from film inner join film_actor using(film_id) where film.film_id > 500;` 
                这里使用 `film_id` 字段进行等值管来奶， `film_id` 这个列不仅适用于 `film` 表且适用于 `film_actor` 表：
                `explain select filem.film_id from film inner join film_actor using(film_id) where film.film_id > 500 and film_actor.film_id > 500;`
          
        * 关联查询
       
            * `join` 的实现原理
            * 案例演示：
        * 排序优化


> CBU RBU
> 
> CBU : 基于成本的优化；
> 
> RBU : 基于规则的优化；


## 优化特定类型的查询

