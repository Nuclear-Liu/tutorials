# 分区表


**分治思想**；
可以根据需要在很大程度上设置的规则在文件系统中分布各个表的部分；
表的不同部分分为单独的表存储在**不同的位置**；
完成数据划分的用户选择规则称为**分区函数**；
在 MySQL 中支持的**分区函数**：**模数**、**与一组范围或值列表的简单匹配**、**内部哈希函数**和**线性哈希函数**；
该函数根据用户指定的分区类型进行选择，将用户提供的**表达式**的值作为其参数；
**表达式**根据**分区类型**支持：**列值**、**作用域一个或多个列值的函数**或**一组或多个列值**；


## 分区表应用场景


1. 表非常大以至于无法全部都放在内存中，或者只在表的最后部分有热点数据，其他均是历史数据；
2. 分区表的树更容易维护；
    * 批量删除大量数据可以使用清除整个分区的方式；
    * 对一个独立分区进行优化、检查和修复等操作；
3. 分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备；
4. 可以使用分区来避免某些特殊瓶颈；
    * InnoDB 的单个索引互斥访问；
    * ext3 文件系统的 inode 锁竞争；
5. 可以备份和恢复独立的分区；


## 分区表的限制


1. 一个表最多只能有 `1024` 个分区，在 5.7 版本可以支持 `8196` 个分区；
2. 在早期的 MySQL 中，分区表达式必须是整数或者是返回整数的表达式；在 MySQL 5.5 中，某些场景可以直接使用列来进行分区；
3. 如果分区字段中有主键或者唯一索引的列，那么**所有主键列和唯一索引列都必须包含进来**；
4. 分区表无法使用外键约束；


## 分区表的原理


分区表由多个相关的底层表实现，底层表由**句柄对象**标识，可以直接访问各个分区；
存储引擎管理分区的各个底层表和管理普通表相同（同一个表的所有底层表必须使用相同的存储引擎）；
分区表的索引在各个底层表上加上一个完全相同的全量索引；
在存储引擎角度，底层表与普通表没有任何不同，存储引擎无需直到具体表类型；


分区表操作逻辑：

* `select`

    查询分区表时，分区层打开并**锁住所有底层表**，优化器首先判断是否可以过滤部分分区，然后调用对应的存储引擎接口访问对应分区的数据；

* `insert`

    插入记录时，分区层打开并**锁住所有底层表**，确定那个分区接收新增记录，将记录写入对应的底层表；

* `delete`

    删除记录时，分区层打开并**锁住所有的底层表**，确定数据对应的分区，从记录所在底层表删除记录；

* `update`

    更新记录时，分区层打开并**锁住所有底层表**，首先确定更新记录所在的分区，然后取出数据并更新，再次判断更新后的记录应该存放那个分区，最后对对应的插入分区做插入操作，对源记录分区进行删除操作；

对于 `select` `delete` `update` 如果 `where` 条件与分区表达式匹配，可以将不包含对应记录的分区过滤掉；

对于 `insert` 根据分区表达式只会命中一个分区，其他分区被过滤；

每个操作都会**打开并锁住所有的底层表**，但并不是处理过程中锁住全表，如果存储引擎能够实现行级锁，则会在分区层释放对应的表锁；


## 分区表的类型


1. `RANGE` 范围分区

    根据列值给定范围内将行分配给分区；

2. 列表分区

    类似于按 `range` 分区，区别在于 `list` 分区时基于列值匹配一个离散值集合中的某个值来进行选择；

3. 列分区

    column 分区（ MySQL 5.5 开始支持）可以认为时 `range` 和 `list` 的升级版，在 MySQL 5.5 之后，使用 `column` 分区替代 `range` 和 `list` ，但是只接受普通列不接受表达式；

4. hash 分区

    基于用户定义的表达式的返回值来进行选择的分区，该表大师用于将要插入到表中的这些行的列值进行计算；这个函数可以包含 MySQL 中有效的、产生非负整数数值的任何表达式；

5. key 分区

    类似于 `hash` 分区，区别在于 `key` 分区只支持一列或多列，且 MySQL 服务器提供其自身的哈希函数，必须有一列或多列包含整数值；

6. 子分区

    在分区的基础之上，再进行分区后存储；


## 如何使用分区表


表中数据量巨大，不可能进行全表扫描，此时可以考虑表的业务特性按照某种属性（例如：时间）进行分区（数据量巨大时，索引也无法起到作用，即使可以使用索引的空间和维护成本大幅增长，还会产生大量碎片和随机 IO，此时最好**不使用索引**）；


1. 全量扫描数据，不要任何索引

    使用简单的分区方式存放表，不使用任何索引，根据分区规则大致定位需求的数据位置，通过使用 `where` 条件将需要的数据限制在少数分区中，此策略适用于以**正常方式访问大量数据**；

2. 索引数据，并分离热点

    数据有明显的**热点**，将热点数据单独存放在一个分区中，让这部分数据可以被缓存，这样查询就可以只访问一个很少的分区表，能够使用索引，也能够有效的使用缓存；


## 在使用分区表的时候注意事项


1. **`null` 会使分区过滤无效**；
2. 分区表和索引列不匹配，会导致查询无法进行分区过滤；
3. 选择分区的成本可能很高；
4. 打开并锁住所有的底层表的成本可能很高；
5. 维护分区的成本可能很高；
