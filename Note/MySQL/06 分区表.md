# 分区表


**分治思想**；
可以根据需要在很大程度上设置的规则在文件系统中分布各个表的部分；
表的不同部分分为单独的表存储在**不同的位置**；
完成数据划分的用户选择规则称为**分区函数**；
在 MySQL 中支持的**分区函数**：**模数**、**与一组范围或值列表的简单匹配**、**内部哈希函数**和**线性哈希函数**；
该函数根据用户指定的分区类型进行选择，将用户提供的**表达式**的值作为其参数；
**表达式**根据**分区类型**支持：**列值**、**作用域一个或多个列值的函数**或**一组或多个列值**；


## 分区表应用场景


1. 表非常大以至于无法全部都放在内存中，或者只在表的最后部分有热点数据，其他均是历史数据；
2. 分区表的树更容易维护；
    * 批量删除大量数据可以使用清除整个分区的方式；
    * 对一个独立分区进行优化、检查和修复等操作；
3. 分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备；
4. 可以使用分区来避免某些特殊瓶颈；
    * InnoDB 的单个索引互斥访问；
    * ext3 文件系统的 inode 锁竞争；
5. 可以备份和恢复独立的分区；


## 分区表的限制


1. 一个表最多只能有 `1024` 个分区，在 5.7 版本可以支持 `8196` 个分区；
2. 在早期的 MySQL 中，分区表达式必须是整数或者是返回整数的表达式；在 MySQL 5.5 中，某些场景可以直接使用列来进行分区；
3. 如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来；
4. 分区表无法使用外键约束；


## 分区表的原理


分区表由多个相关的底层表实现，底层表由**句柄对象**标识，可以直接访问各个分区；
存储引擎管理分区的各个底层表和管理普通表相同（同一个表的所有底层表必须使用相同的存储引擎）；
分区表的索引在各个底层表上加上一个完全相同的全量索引；
在存储引擎角度，底层表与普通表没有任何不同，存储引擎无需直到具体表类型；


分区表操作逻辑：

* `select`

    查询分区表时，分区层打开并**锁住所有底层表**，优化器首先判断是否可以过滤部分分区，然后调用对应的存储引擎接口访问对应分区的数据；

* `insert`

    插入记录时，分区层打开并**锁住所有底层表**，确定那个分区接收新增记录，将记录写入对应的底层表；

* `delete`

    删除记录时，分区层打开并**锁住所有的底层表**，确定数据对应的分区，从记录所在底层表删除记录；

* `update`

    更新记录时，分区层打开并**锁住所有底层表**，首先确定更新记录所在的分区，然后取出数据并更新，再次判断更新后的记录应该存放那个分区，最后对对应的插入分区做插入操作，对源记录分区进行删除操作；

对于 `select` `delete` `update` 如果 `where` 条件与分区表达式匹配，可以将不包含对应记录的分区过滤掉；

对于 `insert` 根据分区表达式只会命中一个分区，其他分区被过滤；

每个操作都会**打开并锁住所有的底层表**，但并不是处理过程中锁住全表，如果存储引擎能够实现行级锁，则会在分区层释放对应的表锁；


## 分区表的类型


## 如何使用分区表


## 在使用分区表的时候注意事项
