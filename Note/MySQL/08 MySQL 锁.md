# MySQL 锁


**锁是计算机协调多个进程或线程并发访问某一资源的机制**。


> 在数据库中，除传统的计算资源（CPU、RAM、IO 等）的争用意外，数据也是一种许多用户共享的资源；
> 锁冲突是影响数据库并发访问性能的一个重要因素；


`MyISAM` 和 `MEMORY` 存储引擎采用的是**表级锁(table-level locking)**；
`InnoDB` 存储引擎即支持**行级锁(row-level locking)**，也支持**表级锁(table-level locking)**，默认情况下采用**行级锁**；


> **表级锁** vs **行级锁**
> 
> **表级锁**：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；
> 
> **行级锁**：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率最低，并发度最高；
> 
> 仅从锁的角度来说：表级锁更适合用于以查询为主，只有少量按索引条件更新数据的应用；


MySQL 锁与引擎有关：


## MyISAM 表锁


`MyISAM` 中锁类型： **表共享读锁(Table Read Lock)**，**表独占写锁(Table Write Lock)**；只能**锁表**；


对 MyISAM 表的**读**操作，**不会阻塞**其他用户对同一表的**读**请求，会阻塞对同一张表的**写**请求；
对 MyISAM 表的**写**操作，则会**阻塞**其他用户对同一表的**读和写**操作；
**MyISAM 表的读操作与写操作之间以及写操作之间是串行的**；


* 获取写锁： `lock table table_name write;`
* 获取读锁： `lock table table_name read;`
* 释放锁： `unlok tables;`


> 注意：
> 
> MyISAM 在执行查询语句之前，会自动给涉及的所有表加读锁，在执行更新操作前，会自动给涉及的表加写锁；不需要用户干预；


* MyISAM 的并发插入问题：

    MyISAM 支持查询和插入操作的并发执行；

    `lock table table_name read local;` : 仅锁定当前会话，不阻塞其他会话的更新和查询，当前锁定会话的查询结果为锁定时的数据状态；
* 通过检查 `Table_locks_waited` `Table_locks_immdiate` 状态变量来分析系统的表锁定争夺(`show variable like '%Table_locks%';`):

    如果 `Table_locks_waited` 越大，说明锁竞争越严重；


## InnoDB 表锁

`InnoDB` 中锁类型： **共享锁**，**排它锁**；可以**锁表**、**锁行**；锁的对象是**索引**，如果锁的列是索引列对应为**行锁**，如果没有索引，会从**行锁**退化成**表锁**；


