# Redis


> 常识：
> 
> * 磁盘
>   1. 寻址 `ms` 级别
>   2. 带宽 `GB` / `MB`
>
> * 内存：
>   1. 寻址 `ns` 级别
>   2. 带宽 `GB` / `MB`
> 
> * I/O buffer ： 体现成本问题
> 
>    磁盘每个扇区 `512Byte` 带来一个成本变大：索引；
>    
>    所以格式化磁盘时， `4K` 对齐， 操作系统读写都已 `4K` 为单位。


> 数据库：
> 
> 数据库中存储数据以 `data page` 为单位，大小为 `4K` 正好与硬件中 `4K` 一致。
> 数据库通过 索引（ `data page` 中存放的是索引）索引实际的存储数据的 `data page` 。
> 
> 关系型数据库建表：必须给出 schema 。
> 
> schema 中包含了表的列数量和列对应的类型（字节宽度）。
> 倾向于行级存储（表中每行数据宽度一定，当存储到磁盘时没有数据的字段会占用空间，未来对数据进行增删改不需要移动数据，可以在对应位置上进行复写）
> 
> 数据和索引都存储在硬盘中，内存中存在一个 B+T 。
> B+T 的树干都是在内存中（区间和偏移），叶子是每一个 `data page` ，如果查询时条件命中索引，会将对应索引读入内存，进而将对应命中的存储数据的 `data page` 读入内存。
> 
> 最终降低 IO 量。


> 数据库表很大的时候：
> 
> 如果有索引，增删改**变慢**，因为要维护索引；
> 如果有索引，查询速度在 B+T 树干都能存放在内存中（不需要出现内存交换），一个或少量查询可以命中索引，仅需要读取一个 `data page` 进入内存，查询速度依然很快；
> 
> 当有并发大的时候，导致大量数据进入内存，受磁盘IO带宽限制，速度下降。

> 数据在磁盘和内存中体积不一样。内存中通过共享机制和压缩机制减少存储空间的需求。

计算机领域的两个基本基础设施：

  * 冯诺依曼体系的硬件
  * TCP/IP 网络

## 缓存


* Memcached

  Memcached Value 没有类型的概念

* Redis

  Redis Value 提供了多种类型

> Memcached 需要全量请求 Value 到 Client 端进行处理；加重网络负担，Client 需要编解码。
> 
> Redis 中类型不是最重要的， Redis 的 Server 中对每种类型都有自己的方法。
> 
> 本质上是解耦；**计算向数据移动**。

## Redis 提供的 `Value` 类型

### `String`
#### `BitMaps`
#### 字符类型
#### 数值类型
### `Hashes`
### `Lists`
### `Sets`
### `Sorted Sets`
