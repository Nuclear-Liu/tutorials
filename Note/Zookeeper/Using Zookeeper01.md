# 

## 连接客户端

```shell
zkCli.sh 
```

```shell
help
```

* `cZxid` 
  
  创建事务 id 全局唯一。 
  
  长度为 `64byte` ；低 `32byte` 表示事务递增序列；高 `32byte` 表示 Leader 纪元（第几个 Leader ）；
 
  当开启新纪元时，事务递增序列从零开始重新递增。

* `mZxid`
  
  修改节点的事务 id

* `pZxid`
  
  当前节点下最后创建的子节点 id
* `cversion`

  版本号

* `ephemeralOwner`

  临时持有者; `0x00` 表示没有持有者，表示持久化节点；或者是当前连接 Client 的 Session id 表示临时节点。


> 当 Client 连接的 `Followers` 不可用， Client 切换到新的客户端，旧 Session id 是否还存在？
> 新连接的 `Followers` Session id 是原来的正确 Session id 。
> 
> 每一个新增的 Client 都会消耗一个事务 id 同步 Session id。
> Client 断开连接，消耗一个事务 id 同步删除对应的 Session id 。

> 当多个客户端同时对一个目录进行创建的时候，可能会出现覆盖。
> 
> 在使用 `create` 命令时使用 `-s` 参数。创建序列化节点。会在目录名称后加一个唯一序列号（依次自增，创建的临时文件名称不一样也会继续自增。）
> 
> 删除所有序列化节点，序列化标识值仍旧继续在原来基础上增加。

> 功能：
> 
> 1. 统一配置管理：所有节点统一视图，而且节点中可以存储 `1MB` 数据；
> 2. 分组管理：命名空间（ path 结构）；
> 3. 统一命名：sequential （序列化能力）；
> 4. 分布式同步：临时节点（Session Id）；

> 应用场景：
> 
> * 分布式锁：
> 
>   单一锁，使用临时节点，不适用序列化；
> 
>   通过临时节点；
>   如果锁依托一个父节点，创建多个临时节点且具备 `-s` 序列化能力，意味着父节点下可以有多把锁。
>   
>   新增的序列化锁，盯住前边的序列化锁，前边的锁消失以后，后边的锁才可以继续操作。
> 
>   这时对应的锁：（公平锁）队列式、事务的锁。
> 
> 
> * HA 选主
> 
>   拿到锁的节点为主节点，没有拿到的从节点。
> 


























