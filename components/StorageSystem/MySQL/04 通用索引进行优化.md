# 通过索引进行优化


> 底层实现使用的是 B+Tree 。
> 
> 选择 B+Tree 的原因：
>
> Hash 表索引缺点(InnoDB, MyISAM)：
> 1. 利用 Hash 存储的话**需要将所有的数据文件加载到内存**，耗费内存空间；
> 2. 如果所有的查询都是**等值查询非常快**，如果是**范围查找数据效率低**（ Hash 表需要遍历整体）；
> 
> 二叉树 (BS-Tree)：
> 
> 数据插入的时候会造成树本身的倾斜，树深度增加，增大系统 IO （每次获取节点都是一次 IO ）；
> 
> 平衡树 (AVL-Tree)
> 
> 为了保证树的平衡，需要进行旋转操作，保证最短子树与最长子树高度差不能超过 `1` （插入删除效率低，查询效率高）。
> 
> 红黑树 (RadBlack-Tree)
> 
> 是 AVL-Tree 的一种，最长子树只要不超过最短子树的两倍即可，通过旋转和变色（变色减少旋转操作）的功能实现插入性能与查询性能达到平衡
> （因为只有两个分支，最终还是会因为节点过深导致 IO 的次数过多）；
> 
> * 左旋：逆时针旋转，将根节点的右节点的左节点给根节点当作右节点，根节点成为右节点的左节点。
> 
> * 右旋：顺时针旋转，将根节点的左节点的右节点给根节点当作左节点，根节点当作右节点的右节点。
> 
> B Tree
> 
> 可以又多个分支。索引节点带有数据，可以支持区间查询，如果命中缓存则直接读取节点下的数据。
> 缺点：索引节点带上了数据信息；导致索引支持的数据索引空间变小。
> 
> B+Tree
> 
> 在 B Tree 的基础上进行优化，让索引的非叶子节点不在携带数据信息，只存储 key 值和指针值；叶子节点直接放置数据，索引的覆盖空间增大。
> 叶子节点又双向指针串联，支持顺序数据各个数据块中的数据。
> 
> B*Tree
> 
> 在 B+Tree 的基础上，在非叶子节点间构建双向指针；
> 
> **非节点叶子节点没有存储数据，所以没有 MySQL 中没有选择 B*Tree**


在 `InnoDB` 和 `MyISAM` 中索引默认都是 B+Tree ；
但是存储数据的格式不一样（导致查找最终数据节点的时候方式不同）：

* `InnoDB` 数据与索引单一文件存储；

  叶子节点中实际存储对应的一整行的数据；

* `MyISAM` 数据与索引单独文件存储；

  叶子节点存放的不是实际的数据，存放的是数据所在数据文件的位置信息；

> **注意：**
> 
> 1. `InnoDB` 是通过 B+Tree 结构对主键创建索引，然后叶子节点中存储记录；如果没有主键，会选择**唯一键**；如果没有**唯一键**，会选择生成一个 `6bite` 的 `row_id` 作为主键；
> 2. 如果创建索引的键是其他字段，**在叶子节点中存储的是该记录的主键**，然后在通过主键索引找到对应的记录，这个过程叫做**回表**；

## 索引基本知识

### 索引的优点


1. 减少服务器扫描的数据量（ IO 量）；
2. 帮助服务器避免**排序**和**临时表**；

  最好不要使用**文件排序**(`explain` 的 `extra` 是： `using filesort`)，尽量使用**索引排序**；

3. 将随机 IO 变成顺序 IO ；


### 索引的用处


1. 快速查找匹配的 `WHERE` 子句的行；

2. 从 `consideration` 中消除行，**如果可以在多个索引之间进行选择， MySQL 通常会使用找到最少行的索引**；

3. 如果表具有多列索引，则优化器可以使用索引的任何最左前缀的来查找行；

4. 当有表连接的时候，从其他表检索行数据；

5. 查找特定索引列的 `min` 或 `max` 值；

6. 如果排序或分组是在可用索引的**最左前缀**上完成的，则对表进行**排序**和**分组**；

7. 在某些情况下，可以优化查询以检索值而无需查询数据行；


### 索引的分类


> 数据库会默认为**唯一键**建索引（所有唯一键，不仅限于主键）；


* 主键索引

* 唯一索引

* 普通索引

* 全文索引

* 组合索引


### 面试技术名词


* 回表

  在 InnoDB 中默认为主键创建索引，当为普通列创建索引时，叶子节点存放的是**主键**，当查询的时候需要再次根据主键索引查询实际的数据行信息，这个过程叫做**回表**；

* 覆盖索引

  如果一个索引包含了（覆盖了）查询语句中的字段或条件就叫做覆盖索引 (`explain` 的 `extra` 是： `using index`) （比如索引中查询主键 id 的情形，在普通索引中已经存在，不需要回表过程，所以叫做覆盖索引）；

* 最左匹配（仅限于组合索引）

  多个列创建索引（组合索引），当查询条件语句忽略了使用最左侧的列而是用了其他列，当前的查询不能使用当前的索引；

* 索引下推

  （前提条件是组合索引，组合索引满足最左匹配，但是遇到非等值判断时匹配停止）当条件中出现索引内容的条件的时候，在索引数据的阶段对数据进行过滤，省略到数据到数据库 server 层的时候的判断计算（降低了 IO 量）；

* 索引合并

  高版本支持索引合并，但是效率不一定高；

> 谓词下推
> 
> `select t1.name, t2.name from ti join t2 on ti.id = t2.id;`
> 
> 根据id 对 t1 t2 进行关联，然后取出需要的字段；
> 
> 先把 t1.id t1.name t2.id t2.name 取出，然后进行关联；
> 
> 谓词(动词)


### 索引匹配方式


* 全值匹配(type: `ref`)

  全值匹配指（条件）的是和索引中的所有列进行匹配；

  `explain select * from staffs where name = 'July' and age = 23 and pos = 'dev';`

* 匹配最左前缀(type: `ref`)

  只匹配前面的几列；

  `explain select * from staffs where name = 'July' and age = 25;`

* 匹配列前缀(`using index condition`, type: `range`)

  可以匹配某一列的值的开头部分；

  `explain select * from staffs where name like 'J%';`

  `explain select * from staffs where name like '%y';`

* 匹配范围值(`using index condition`, type: `range`)

  可以查找某一个范围的数据；

  `explain select * from staffs where name > 'Mary';`

* 精确匹配某一列并范围匹配另一列(`using index condition`, type: `range`, ref: `null`)

  可以查询第一列的全部和第二列的部分；

  `explain select * from staffs where name = 'July' and age > 35;`

* 只访问索引查询(`using index`, type: `ref`, ref: `const`)

  查询的时候只需要访问索引，不需要访问数据行，本质上是**覆盖索引**；

  `explain select name, age, pos from staffs where name = 'July' and age = 25 and pos = 'dev';`


## 哈希索引


在 MySQL 中，只有 `memory` 的存储引擎显式支持哈希索引；
基于哈希表的实现，只有**精确匹配索引所有列**的查询才有效；


> 哈希索引只需要存储对应的 hash 值，所以索引的结构十分紧凑，这让哈希索引查找的速度非常快；


### 哈希索引的限制


1. 哈希索引只包含哈希值和**行指针**，而不存储字段值，索引不能使用索引中的值来避免读取行；
2. 哈希索引数据并不是按照索引顺序存储的，所以**无法进行排序**；
3. 哈希索引**不支持部分列匹配查找**，哈希索引是使用索引列的全部内容来计算哈希值；
4. 哈希表支持等值比较查询，**不支持任何范围查询**；
5. 访问哈希表索引的数据非常快，除非有很多哈希冲突，当出现哈希冲突的时候，存储引擎必须遍历链表中的所有行指针，逐行进行比较。直到所有符合条件的行；
6. 哈希冲突如果比较多，维护代价增大；


### 案例


当需要存储大量的 URL ，并且根据 URL 进行搜索查找，如果使用 B+Tree ，存储的内容就会很大： `select id from url where url = '';` ；
可以将 URL 使用 `CRC32` 算法做哈希，可以使用一下查询： `select id from url where url = '' and url_crc = CRC32('url');` ;
利用体积小的 `CRC32` 索引来完成查询；


## 组合索引


当包含多个列作为索引，需要注意的是争取的顺序依赖于该索引的查询，同时需要考虑如何更好的满足**排序**和**分组**的需要（索引的顺序）；


> 创建索引考虑的问题；
> 
> * 索引顺序
> * 索引大小

## 聚簇索引与非聚簇索引


### 聚簇索引 (InnoDB)


不是单独的索引类型，而是一种**数据存储方式**，指的是**数据行跟相邻的键值紧凑的存储在一起**；


#### 优点


1. 可以把相关数据保存在一起；
2. 数据访问更**快**，因为索引和数据保存在同一个树中；
3. 使用**覆盖索引**扫描的查询可以直接使用页节点中的主键值；


#### 缺点


1. 聚簇索引数据量大限度地**提高 IO 密集型应用的性能**，如果数据全部在内存，那么聚簇索引就没有什么优势；
2. 插入速度严重依赖于**插入顺**序，按照主键的**顺序插入是最快的方式**；

    B+Tree 每个叶子节点存储的数据大小是一定的，如果页节点没有足够的空间会涉及到**页分裂**的过程

3. **更新聚簇索引列**的代价很高，因为会强制将每个被更新的行移动到新的位置；
4. 基于聚簇索引的表的插入新行，或者主键被更新导致需要移动数据行的时候，可能面临**页分裂**的问题；
5. 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于**页分裂**导致数据存储不连续的时候；


> **页分裂**
> 
> 将原有的数据页分裂为两个数据页（一般是因为主键插入，导致原有也空间不能存放新数据，页按照要插入的位置分裂为前后两个新的页节点）；
> 
> **页合并**
> 
> 将两个数据页进行合并（一般是由于数据删除导致页节点所在空间不在有数据信息，导致页的合并）；


在移动迁移数据时，可以先把创建索引关闭，数据迁移完成后再把索引打开创建索引属性打开；


### 非聚簇索引 (MyISAM)


数据文件跟索引文件分开存放；


## 覆盖索引


* 如果一个索引包含所有需要查询的字段的值，称之为**覆盖索引**；
* 不是所有类型的索引都可以称为**覆盖索引**，覆盖索引必须**存储列的值**；
* 不同的存储实现覆盖索引的方式不同，不是所有的引擎都支持覆盖索引（ `memory` 不支持覆盖索引）；


extra: `using index`


### 优势


1. 索引条目通常小于数据行大小，如果只需要读取索引，那么 MySQL 就会极大的较少数据访问量；
2. 因为索引是按照索引顺序存储的，所以对于 IO 密集型和范围查询会比随机从磁盘读取每一行数据的 IO 要少得多；
3. 一些存储引擎（如 MyISAM ）在内存中只缓存索引，数据则依赖于操作系统来缓存，因此访问数据需要一次系统调用，这可能会导致严重的性能问题；
4. 由于 InnoDB 的聚簇索引，覆盖索引对 InnoDB 表特别有用；


## 优化细节

1. 当使用索引列进行查询的时候尽量不要使用表达式，把计算放到业务层而不是数据库层；

    `explain select actor_id from actor where actor_id = 4;`: (type: `const` extra: `using index`)

    `explain select actor_id from actor where actor_id + 1 = 5;`: (type: `index` extra: `using where`)

2. 尽量使用主键查询，而不是其他索引，因为主键查询不会触发**回表**查询；

3. 使用前缀索引；

    有时候需要索引很长的字符串，这会让索引变的大且慢，通常情况下可以使用某个列开始的部分字符串，这样大大的节约索引空间，从而提高索引效率，但这会降低索引的选择性
    （索引的选择性是指不重复的索引值和数据表记录总数的比值，范围从 `1/#T` 到 `1` 之间。
    索引的选择性越高则查询效率越高（选择性越高的索引可以让 MySQL 过滤掉更多的行）。

    一般情况下某个列前缀的选择性也是足够高的，足以满足查询的性能；
    对应 `BLOB` `TEXT` `VARCHAR` 类型的列，**必须要使用前缀索引**（ MySQL 不允许索引这些列的完整长度，使用该方法的诀窍是**选择足够长的前缀保证较高的选择性，通常又不能太长**）；

    创建前缀索引： `alter table citydemo add key(city(7));`

    OLAP 联机分析系统：基数(Cardinality)：去重之后的唯一值的统计数量； `HyperLogLog` 算法；

    MySQL 无法使用**前缀索引**做 `order by` 和 `group by` 。

    ```sql
    select 
           count(distinct left(city,3))/count(*) as sel3,
           count(distinct left(city,4))/count(*) as sel4,
           count(distinct left(city,5))/count(*) as sel5,
           count(distinct left(city,6))/count(*) as sel6,
           count(distinct left(city,7))/count(*) as sel7,
           count(distinct left(city,8))/count(*) as sel8 
    from citydemo;
    ```

4. 使用索引扫描排序；

    extra: `using filesort` 未使用索引扫描排序；

    MySQL 可以使用同一个索引即满足排序，又用于查找行，如果可以，设计索引的时候尽量同时满足这两种任务；

    只有当**索引的列顺序**和 `order by` 子句的顺序完全一致，并且**所有列的排序方式都一样**时， MySQL 才能够使用索引来对结果进行排序；
    如果查询需要关联多张表，则只有当 `order by` 子句**引用的字段全部为第一张表**时，才能使用索引来排序；
    `order by` 子句和查找型查询得限制是一样的，**需要满足索引的最左前缀的要求**（与 `where` 语句一起，或者单独），否则， MySQL 都需要执行顺序操作，而无法利用索引排序；
    如果 `order by` 对多个字段进行排序，与索引中的排序交叉不一致，此时无法使用索引扫描排序；

    组合索引默认是升序排列；

5. `union` `all` `in` `or` 都能够使用索引，**推荐使用** `in` ；

    `explain select * from actor where actor_id = 1 union all select * from actor where actor_id = 2;`

    `explain select * from actor where actor_id in (1, 2);`

    `explain select * from actor where actor_id = 1 or actor_id = 2;`

    `in` 与 `or` 执行计划一样，但是执行时间会不一致； `in` 会快于 `or` ；

6. 范围列可以用到索引；

     * 范围条件是： `<` `<=` `>` `>=` `between`
     * 范围列可以用到索引，但是范围列后面的列无法用到索引，索引最多用于一个范围列；

7. **强制类型转换**会全表扫描；

    `phone:varchar(20)`

    `explain select * from user where phone = 13800001234;` type: `ALL`

    `explain select * from user where phone = '13800001234';` type: `ref`

8. **更新**十分频繁，数据**区分度不高**的字段不宜建立索引；

    * 更新需要变更 B+Tree ，维护成本增加，数据库性能下降；
    * 字段值区间少不建议建立索引，不能有效的过滤数据；
    * 一般区分度在 `80%` 以上的时候就可以建立索引，区分度可以使用 `count(distinct(colum_name))/count(*)` 来计算；

9. 创建索引的列，不允许为 `null` ，避免得到不符合预期的结果；

10. 当需要进行表连接的时候，最好不要超过三张表，因为需要 `join` 的字段，**数据类型**必须一致；

    `join` 使用 `nested-loop` 嵌套循环算法；

    * Simple Nested-Loop Join: `r join s on r.cl = s.cl` （驱动表与匹配表具体要看优化）
        
        `r` 为驱动表， `s` 为匹配表， `r` 中取出每一个记录去匹配 `s` 的所有列，然后进行合并数据；
    
    * Index Nested-Loop Join:

        要求 `s.cl` 有索引；通过索引来减少比较，加速查询；

        在查询是，驱动表会根据关联字段的索引进行查询，当在索引上找到符合的值，再回表进行查询；
        如果非驱动表对应的链表查询索引是主键性能会非常高，如果不是主键，需要进行多次回表查询；
    
    * Block Nested-Loop Join:

        如果有索引，会采取 `Index Nested-Loop Join` 方式进行，如果 `join` 列没有索引，会次啊用 `Block Nested-Loop Join` ；
        
        将驱动表的所有 `join` 相关的列都先缓存到 `join buffer` 中，然后批量与匹配表进行匹配，降低驱动表的访问频次；

        默认情况下 `join_buffer_size = 256K` ，在查找的时候 MySQL 会将所有的需要列缓存到 `join buffer` 中，包括 **`select` 的列**，而不仅仅是关联列；
        在一个有 `N` 个 `JOIN` 关联的 SQL 执行分配 **`N-1` 个 `join buffer`**。

11. 如果明确直到只有一条结果返回， `limit 1` 能够提高效率；

    `limit` 用于**限制输出**；

12. 单表索引建议控制在 `5` 个以内；

13. 单表索引（组合索引）字段不允许超过 `5` 个；


> 创建索引的时候应该避免以下错误概念：
> 
> * 索引越多越好；
> 
> * **过早优化**，在不了解系统的情况下进行优化；


## 索引**监控**


`show status like 'Handler_read%';`

* 参数解释：

    * `Handler_read_first` : 读取索引第一个条目的次数
    * `Handler_read_key` : 通过 `index` 获取数据的次数
    * `Handler_read_last` : 读取索引最后一个条目的次数
    * `Handler_read_next` : 通过索引读取下一条数据的次数
    * `Handler_read_prev` : 通过索引读取上一条数据的次数
    * `Handler_read_rnd` : 从固定位置读取数据的次数
    * `Handler_read_rnd_next` : 从数据节点读取下一条数据的次数
