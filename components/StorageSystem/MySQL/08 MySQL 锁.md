# MySQL 锁


**锁是计算机协调多个进程或线程并发访问某一资源的机制**。


> 在数据库中，除传统的计算资源（CPU、RAM、IO 等）的争用意外，数据也是一种许多用户共享的资源；
> 锁冲突是影响数据库并发访问性能的一个重要因素；


`MyISAM` 和 `MEMORY` 存储引擎采用的是**表级锁(table-level locking)**；
`InnoDB` 存储引擎即支持**行级锁(row-level locking)**，也支持**表级锁(table-level locking)**，默认情况下采用**行级锁**；


> **表级锁** vs **行级锁**
> 
> **表级锁**：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；
> 
> **行级锁**：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率最低，并发度最高；
> 
> 仅从锁的角度来说：表级锁更适合用于以查询为主，只有少量按索引条件更新数据的应用；


MySQL 锁与引擎有关：


## MyISAM 表锁


`MyISAM` 中锁类型： **表共享读锁(Table Read Lock)**，**表独占写锁(Table Write Lock)**；只能**锁表**；


对 MyISAM 表的**读**操作，**不会阻塞**其他用户对同一表的**读**请求，会阻塞对同一张表的**写**请求；
对 MyISAM 表的**写**操作，则会**阻塞**其他用户对同一表的**读和写**操作；
**MyISAM 表的读操作与写操作之间以及写操作之间是串行的**；


* 获取写锁： `lock table table_name write;`
* 获取读锁： `lock table table_name read;`
* 释放锁： `unlok tables;`


> 注意：
> 
> MyISAM 在执行查询语句之前，会自动给涉及的所有表加读锁，在执行更新操作前，会自动给涉及的表加写锁；不需要用户干预；


* MyISAM 的并发插入问题：

    MyISAM 支持查询和插入操作的并发执行；

    `lock table table_name read local;` : 仅锁定当前会话，不阻塞其他会话的更新和查询，当前锁定会话的查询结果为锁定时的数据状态；
* 通过检查 `Table_locks_waited` `Table_locks_immdiate` 状态变量来分析系统的表锁定争夺(`show variable like '%Table_locks%';`):

    如果 `Table_locks_waited` 越大，说明锁竞争越严重；


## InnoDB 表锁


`InnoDB` 中锁类型： **共享锁**，**排它锁**；可以**锁表**、**锁行**；锁的对象是**索引**，如果锁的列是索引列对应为**行锁**，如果没有索引，会从**行锁**退化成**表锁**；


### 事务及其 ACID 属性


事务是由一组 SQL 语句组成的逻辑处理单元，事务具有 `ACID` 4 属性；

* `A`(Actomicity) : 原子性；基于 `undo log` 实现;事务是一个原子操作单元；
* `C`(Consistent) : 一致性；基于 `AID` 实现；在事务开始和完成时，数据都必须保持一致状态；
* `I`(Isolation) : 隔离性；通过锁机制实现；数据库提供隔离机制，保证事务在不受外部并发操作影响的**独立**环境执行；
* `D`(Durable) : 持久性；基于 `redo log` 实现；事务完成之后，对数的修改是持久性的，即使出现系统故障也能够保持；


### 并发事务带来的问题


并发事务处理能力增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持更多用户并发操作；
同时会带来以下问题：

1. 脏读

    一个事务正在对一条记录做修改，在事务提交前，记录的数据处于不一致状态；
    此时另一个事务读同一条记录，如果不加控制，第二个事务读取到**脏**数据，并据此做进一步的处理，产生对未提交的数据依赖关系；
    这种现象叫做**脏读**；

2. 不可重复读
    
    一个事务在读取某些数据已经发生了改变，或某些记录已经被删除了；
    这种现象叫做**不可重复读**；
3. 幻读

    一个事务按相同的查询条件重新读取以前检索过的数据，发现其他事务插入了一条满足其查询条件的新数据；这种现象称为**幻读**；

上述问题是**数据库读一致性**问题，可以通过**事务的隔离机制**进行保证；


数据库的事务隔离越严格，并发副作用就越小，付出的代价也越高；
因为事务的本质就是使事务在一定程度上串行化，应根据具体的业务需求来决定使用哪种隔离级别；


> 检查 InnoDB 锁争夺：
> 
> 通过查看 InnoDB `Innodb_row_lock` 状态变量来分析系统上的行锁争夺情况：
> 
> `shwo status like '%Innodb_row_lock%';`
> 
> 如果 `Innodb_row_lock_waits` `Innodb_row_lock_time_avg` 值比较高，说明锁争用比较严重


### InnoDB **行锁**模式及加锁方法

#### 锁类型

* 共享锁 (S Lock) ：又称**读锁**；

    （读共享）多个事务对于同一数据共享同一把锁，都可以访问数据库，只能读不能修改；

    事务 A ： `select * from table_name where id = 1 lock in share mode;` 开启共享读锁获取查询，获取数据后不提交事务；

    事务 B： `select * from table_name where id =1;` 可以正常获取数据；

    事务 B： `update table set name = 'xx' where id = 1;` 更新阻塞，只有事务 A 事务提交后修改才可以成功；

* 排它锁 (X Lock) ：又称**写锁**；

    （写独占）排它锁不能与其他锁并存；只有获取了排它锁的事务可以对数据进行读取和修改；

    `delete` `update` `insert` 默认是排它锁；

    事务 A： `select * from table_name where id = 1 for update;` 开启排它锁，使用后不提交事务；

    事务 B： `select * from table_name where id = 1 for update;` `select * from table_name where id = 1 lock share in mode;` 关闭事务自动提交，使用**共享锁**或者**排它锁**都将阻塞；


* 意向共享锁 (IS Lock) ：

    表示事务准备给数据行加入共享锁，即一个数据行在加共享锁之前必须先取得该表的 `IS` 锁（InnoDB 在自动处理不需要用户干预）；

* 意向排它锁 (IX Lock) ：

    表示事务准备给数据行加入排它锁，即一行数据加排它锁之前必须先取得该表的 `IX` 锁（InnoDB 在自动处理不需要用户干预）；

* 间隙锁 ：
* 自增锁 ：

    针对自增列自增长的特殊表级别锁；

    `show variables like '%innodb_autoinc_lock_mode%';` : 

    * `1` 默认值，表示连续，事务未提交则 `id` 永久丢失；
    * `0` 
    * `2` 

#### InnoDB 行锁实现方式

InnoDB 的行锁通过索引中的**索引项**加锁实现；

> InnoDB 行锁实现特点意味着：只有通过索引条件检索数据， InnoDB 才使用**行级锁**，否则将使用**表锁**；
