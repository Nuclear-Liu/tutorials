# `@SneakyThrows`


To boldly throw checked exceptions where no one has thrown them before!


大胆地抛出之前没有人抛出过的已检查异常！


## Overview


`@SneakyThrows` can be used to sneakily throw checked exceptions without actually declaring this in your method's `throws` clause. 
This somewhat contentious ability should be used carefully, of course. 
The code generated by lombok will not ignore, wrap, replace, or otherwise modify the thrown checked exception; it simply fakes out the compiler. 
On the JVM (class file) level, all exceptions, checked or not, can be thrown regardless of the `throws` clause of your methods, which is why this works.

`@SneakyThrows` 可用于偷偷地抛出已检查的异常，而无需在方法的 `throws` 子句中实际声明。
当然，这种有点争议的能力应该谨慎使用。
lombok 生成的代码不会忽略、包装、替换或以其他方式修改抛出的检查异常；它只是伪造了编译器。
在 JVM（类文件）级别，无论您的方法的 `throws` 子句如何，所有异常，无论是否检查，都可以抛出，这就是为什么它有效。


Common use cases for when you want to opt out of the checked exception mechanism center around 2 situations:


当您想要选择退出已检查异常机制时的常见用例围绕 2 种情况：


* A needlessly strict interface, such as `Runnable` - whatever exception propagates out of your `run()` method, checked or not, it will be passed to the `Thread`'s unhandled exception handler. 
  Catching a checked exception and wrapping it in some sort of `RuntimeException` is only obscuring the real cause of the issue.
* An 'impossible' exception. 
  For example, `new String(someByteArray, "UTF-8");` declares that it can throw an `UnsupportedEncodingException` but according to the JVM specification, UTF-8 must always be available. 
  An `UnsupportedEncodingException` here is about as likely as a `ClassNotFoundError` when you use a `String` object, and you don't catch those either!


* 一个不必要的严格接口，例如 `Runnable` - 无论从你的 `run()` 方法传播出的异常，无论是否检查，它都会被传递给 `Thread` 的未处理异常处理程序。
  捕获已检查的异常并将其包装在某种 `RuntimeException` 中只会掩盖问题的真正原因。
* 一个“不可能”的例外。
  例如， `new String(someByteArray, "UTF-8");` 声明它可以抛出一个 `UnsupportedEncodingException` ，但根据 JVM 规范，UTF-8 必须始终可用。
  当你使用一个 `String` 对象时，这里的 `UnsupportedEncodingException` 和 `ClassNotFoundError` 的可能性差不多，而且你也没有捕捉到它们！


Being constrained by needlessly strict interfaces is particularly common when using lambda syntax (`arg -> action`); however, lambdas cannot be annotated, which means it is not so easy to use `@SneakyThrows` in combination with lambdas.


在使用 lambda 语法（`arg -> action`）时，受到不必要的严格接口的约束尤为常见；然而，lambdas 不能被注释，这意味着将 `@SneakyThrows` 与 lambda 结合使用并不是那么容易。


Be aware that it is impossible to `catch` sneakily thrown checked types directly, as javac will not let you write a `catch` block for an exception type that no method call in the try body declares as thrown. 
This problem is not relevant in either of the use cases listed above, so let this serve as a warning that you should not use the `@SneakyThrows` mechanism without some deliberation!


请注意，不可能直接 `catch` 偷偷抛出的已检查类型，因为 javac 不会让您为 try 主体中没有方法调用声明为抛出的异常类型编写 `catch` 块。
这个问题在上面列出的任何一个用例中都不相关，所以让它作为一个警告，你不应该在未经深思熟虑的情况下使用 `@SneakyThrows` 机制！


You can pass any number of exceptions to the `@SneakyThrows` annotation. 
If you pass no exceptions, you may throw any exception sneakily.


您可以将任意数量的异常传递给 `@SneakyThrows` 注释。
如果你没有通过异常，你可以偷偷地抛出任何异常。


## Supported configuration keys:


`lombok.sneakyThrows.flagUsage =` [`warning` | `error`] (default: not set)


Lombok will flag any usage of `@SneakyThrows` as a warning or error if configured.


如果已配置，Lombok 会将任何使用 `@SneakyThrows` 的情况标记为警告或错误。


## Small print


Because `@SneakyThrows` is an implementation detail and not part of your method signature, it is an error if you try to declare a checked exception as sneakily thrown when you don't call any methods that throw this exception. 
(Doing so is perfectly legal for `throws` statements to accommodate subclasses). Similarly, `@SneakyThrows` does not inherit.


因为 `@SneakyThrows` 是一个实现细节，而不是你的方法签名的一部分，如果你在不调用任何抛出此异常的方法时尝试将已检查异常声明为偷偷地抛出，则会导致错误。
（这样做对于 `throws` 语句来容纳子类是完全合法的）。同样， `@SneakyThrows` 不继承。


For the nay-sayers in the crowd: 
Out of the box, Eclipse will offer a 'quick-fix' for uncaught exceptions that wraps the offending statement in a `try`/`catch` block with just `e.printStackTrace()` in the `catch` block. 
This is so spectacularly non-productive compared to just sneakily throwing the exception onwards, that Roel and Reinier feel more than justified in claiming that the checked exception system is far from perfect, and thus an opt-out mechanism is warranted.


对于人群中的反对者：
开箱即用，Eclipse 将为未捕获的异常提供“快速修复”，将违规语句包装在 `try`/`catch` 块中，仅在 `catch` 块中使用 `e.printStackTrace()`。
与只是偷偷摸摸地向前抛出异常相比，这是非常无效率的，以至于 Roel 和 Reinier 认为检查异常系统远非完美是合理的，因此选择退出机制是必要的。


If you put `@SneakyThrows` on a constructor, any call to a sibling or super constructor is excluded from the `@SneakyThrows` treatment. 
This is a java restriction we cannot work around: Calls to sibling/super constructors MUST be the first statement in the constructor; they cannot be placed inside `try`/`catch` blocks.


如果将 `@SneakyThrows` 放在构造函数上，则对同级或超级构造函数的任何调用都将被排除在 `@SneakyThrows` 处理之外。
这是我们无法解决的 Java 限制：对 sibling/super 构造函数的调用必须是构造函数中的第一条语句；它们不能放在 `try`/`catch` 块内。


`@SneakyThrows` on an empty method, or a constructor that is empty or only has a call to a sibling / super constructor results in no `try`/`catch` block and a warning.


`@SneakyThrows` 对空方法、空构造函数或仅调用同级超级构造函数的构造函数不会导致 `try`/`catch` 块和警告。
