# [Zookeeper](https://zookeeper.apache.org/) 分布式协作服务

> Redis 主从复制集群依靠 Sentinel 实现 HA 。
> 
> 主从复制集群的数据不是绝对的实时同步。
> 
> 约等于没有一致性。
> 
> 完成分布式协作（雪崩、穿透是防止并发全部压入后端数据库）需要使用**分布式锁**。
> 分布式锁处理过于复杂。
> 
> 通过 Zookeeper 分布式协调实现分布式锁。

# Overview

1. 维护配置信息
2. 命名
3. 提供分布式同步
4. 提供组服务

> 分层命名空间：类似于标准文件系统

分布式模型：

* 角色角度：主从模型，无主模型

* 数据角度：同步（复制）模型，分片模型

ZooKeeper 是主从架构的复制集群，由 `Leader` 节点（负责增删改请求）和 `Followers` （负责读请求）；
所有的客户端连接随机连接到 Followers 上，对数据的增删改最终转移到 `Leader` 节点操作。

> 主从架构的复制集群， `Leader` 节点不可用， HA 如何保证？
> 
> 集群会有两种状态：可用状态（主从复制集群）和不可用状态（ Leader 不可用，无主模型 ）
> 
> * Zookeeper 集群极其高可用：可以快速的恢复出一个 `Leader` ，通过**推让制**选择 `Leader`

节点可以存储最多 `1M` 数据，不要把 Zookeeper 用作数据库。

> 数据量小才可以保证节点间同步数据的速度，减少网络带宽和数据时延。
> 同时造成写的操作占的比重增加。

每个客户端连接到 Zookeeper 都有一个 Session 表述一个连接。

节点：节点支持**序列节点**
* 持久节点：
* 临时节点： `Session`


> 分布式锁（设置的超时时间 < 事务处理时间）：
> 
> 在 Zookeeper 之前，需要引入一个线程更新超时时间，导致客户端代码复杂度增加。
> 
> 在 Zookeeper 下利用临时节点的 `Session` 维护锁状态，不需要客户端单独写代码维护锁过期时间，当临时节点消失，锁即释放。
> 如果处理的 Client 不可用，连接失效 `Session` 失效。

Zookeeper 提供的保证：

* 顺序一致性：客户端的更新将按发送的顺序应用。（写请求，由单机 `Leader` 完成，所以可以容易实现顺序性。）
* 原子性：更新成功或失败。没有部分结果（要么所有节点更新成功，要么所有节点更新失败；）。

  > 使用的不是强一致性，使用最终一致性，过半节点跟更新成功为成功，更新失败即失败。

* 单一系统映像：客户端将看到相同的服务试图，而不管它连接的服务器如何。即，即使客户端故障转移到具有相同会话的不同服务器，客户端也永远不会看到系统的旧视图。
* 可靠性：应用更新后，它将从那时起持续存在，直到客户端覆盖更新。也可以称为持久性。
* 及时性：系统的客户视图保证在一定的时间范围内是最新的。（最终一致性）
