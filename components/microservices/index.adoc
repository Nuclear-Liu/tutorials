= Microservices
Hui.Liu <mexn-0808@outlook.com>
:toc: left
:toclevels: 5
:toc-title: 目录

== 1. 微服务简介

微服务架构是将整体应用程序拆分为更小的组件，这实现了两个主要目标：

* 更快的开发，实现持续部署
* 手动或自动扩展更容易

微服务本质上是一个**自治的软件组件**；可以独立升级、可替换和可扩展，实现更快的开发并更容易扩展应用程序。

[TIP]
--
自治组件必须满足如下标准：

* 它必须符合**无服务共享架构**：微服务之间不会共享数据库中的数据
* 它**只能通过定义良好的接口进行通信**：要么使用 API 和同步服务，要么最好通过异步消息；
+
所使用的 API 和消息格式必须是稳定的、有良好文档记录的，并通过遵循定义的版本控制策略进行演进
* 它必须部署为**独立的运行时进程**：微服务的每个实例都在单独的运行时进程中运行
* 微服务实例是**无状态**的：微服务的传入请求可以由其他任何实例处理
--

[NOTE]
--
**微服务的大小**：

. 小到足以适合开发人员**的头脑
. 足够大，不会损害**性能(即**延迟**)和**数据一致性**(存储在不同微服务中的数据之间不再是认为理所当然然的需要 SQL 外键)
--

=== 1.1 微服务面临的挑战

自主软件组件可能带来一些挑战，同样适用于微服务：

* 在高负载下，使用同步通信的微服务组件可能会导致一系列故障问题
* 使许多微服务组件的配置保持最新可能具有挑战性
* 跟踪定位正在处理且涉及多个组件的请求困难（例如：在执行根本原因分析时，每个组件都在本地存储日志记录）
* 在微服务组件级别分析硬件资源的使用情况具有挑战性
* 微服务组件的手动配置和管理变得成本高昂且容易出错

[TIP]
--
**分布式计算的 8 个谬误**：
基本上每个人在初始构建分布式应用程序时都会做出以下八个假设；
从长远来看，所有这些都被证明是错误的，并且都会造成大麻烦和痛苦的学习经理。

. 网络可靠
. 延迟为零
. 带宽无限
. 网络安全
. 拓扑不变
. 管理员一名
. 传输成本为零
. 网络是同构的

:彼得·多伊奇, 1994
--

一个好的经验法则是**基于系统环境中总会出现问题的假设来设计微服务架构**。
微服务需要设计架构来处理这些问题，包括检测问题和重新启动故障组件。

=== 1.2 微服务的设计模式

了解如何使用 Spring Boot、Spring Cloud、Kubernetes 和 Istio 实现设计模式来缓解微服务的挑战。

主要涵盖一些内容相关模式：

* 服务发现
* 边缘服务器
* 反应式微服务
* 配置中心
* 集中日志分析
* 分布式追踪
* 熔断
* 链路控制
* 集中监控与告警

==== 服务发现

. 问题： 客户端如何发现微服务及其实例？
+
微服务实例通常在启动时(例如在容器中运行时)分配动态 IP 地址。
使得客户端很难向微服务发出请求。

. 解决方案
+
添加一个新组件——**服务发现**服务——添加到系统环境中，它**跟踪当前可用的微服务及其实例的 IP 地址**。

. 解决方案的要求

* 在微服务及其实例出现和消失时**自动注册/取消注册**
* 客户都安必须能够向微服务的**逻辑端点**发出请求。该请求将被路由到可用的微服务实例之一
* 对微服务的请求必须在可用实例上进行**负载均衡**
* 必须能够检测不健康的实例，以便请求不会被路由到它们

这种设计模式可以使用两种不同的策略来实现：

* *客户端路由*：客户端使用与服务发现服务**通信的库**来查找向其发送球球的正确实例。(Netflix Eureka)
* *服务器端路由*：服务发现服务的基础设施还公开了所有请求都发送到的反向代理，反向代理代表客户端将请求转发到适当的微服务实例。(Istio Sidecar)

==== 边缘服务器

. 问题
+
在微服务系统环境中，多数情况下，希望将一些微服务暴露给系统环境的外部，并掩藏其余的微服务以防止外部访问。
必须保护微服务免受恶意客户端的请求。

. 解决方案
+
添加新组件(边缘服务器，网关)，使所有传入请求都经过边缘服务器处理。
+
边缘服务器的行为类似于反向代理，并且可以与服务发现集成提供负载均衡能力。

. 解决方案的要求

* 隐藏不应暴露在其上下文之外的内部服务；即仅将请求路由到配置为允许外部请求的微服务
* 暴露外部服务并保护其免受恶意请求：即使用 OAuth、OIDC、JWT Token 和 API 密钥等标准协议和最佳实践来确保客户端值得信赖

==== 反应式微服务

. 问题
+
习惯使用阻塞 I/O 来实现同步通信（例如：通过 HTTP 的 RESTful JSON API），使用阻塞 I/O 意味着操作系统会根据请求的长度分配一个线程。
+
如果并发请求数量增加，服务器可能快速耗尽操作系统的可用线程，导致响应时间延长甚至导致服务器崩溃。
+
使用微服务架构时问题更加明显，通常使用一些列协作微服务来处理请求。
服务请求所涉及的微服务越多，可用线程耗尽的速度越快。

. 解决方案
+
使用非阻塞 I/O ，以确保在等待另一个服务中发生处理时不会分配任何线程。

. 解决方案的要求

* 如果可行，使用异步编程模型，发送消息而不等待接收者处理它们
* 如果使用同步编程模型，请使用反应式框架：
+
可以使用非阻塞 I/O 执行同步请求，而无需在等待响应时分配线程。使微服务更容易扩展，以处理增加的工作负载
* 微服务必须设计的具有**弹性**和**自我修复**能力：
+
弹性意味即使它所依赖的服务之一失败，也能产生响应；
+
自我修复意味即使故障，一旦服务再次运行必须能够恢复。

==== 配置中心

. 问题
+
单体架构中应用程序与其配置一起部署；
给定一个基于微服务架构的系统环境，即部署大量微服务实例，会出现一些查询：

* 如何全面了解所有正在运行的微服务实例的配置？
* 如何更新配置并确保所有受影响的微服务实例均已正确更新？

. 解决方案
+
添加新组件——**配置中心**服务到系统环境中，存储所有微服务配置。

. 解决方案的要求
+
可以将一组微服务的配置信息**存储**在一个位置，并针对**不同的环境**使用不同的设置。

==== 集中日志分析

. 问题
+
单体架构中应用程序将日志事件写入在应用程序运行的服务器本地文件系统中的日志文件。
给定一个基于微服务的系统环境，即在大量较小的服务器上部署大量的微服务实例，存在一些问题：

* 当每个微服务实例写入自己的本地日志时，如何描述系统环境中发生的情况？
* 如何确定是否有任何微服务实例遇到**问题**并开始将错误消息写入其日志文档？
* 如果最终客户端报告问题，如何找到相关日志消息：如何确定哪个微服务实例的问题时根本原因？

. 解决方案
+
添加新组件——**集中式日志分析**组件，并实现如下功能：

* **检测**新的微服务**实例**并从中**收集日志事**件
* 在中央数据库中以**结构化**且**可搜索**的方式**解释**与**存储**日志事件
* 提供用于查询和分析日志事件的 API 和图形工具

. 解决方案的要求

* 微服务将日志事件流式传输到标准系统输出 `stdout` ，与将日志写入日志文件相比，使得日志收集器更容易找到日志事件
* 微服务使用有关分布式追踪设计模式所描述的相关 ID 来标记日志事件
* 定义规范日志格式，以便日志收集者可以将从微服务收集的日志事件转换为规范日志格式，然后将日志事件存储到中央数据库中：便于检索和分析日志事件。

==== 分布式追踪

. 问题
+
在处理对系统环境的外部请求时必须可以追踪微服务之间流动的请求和消息。
+
部分故障场景示例：

* 如果最终用户开始提交有关特定故障的支持案例，如何识别导致问题的微服务：即根本原因？
* 如果一个支持案例与特定实体相关：例如特定订单号，如何查找与处理此特定订单相关的日志消息，来处理该订单所涉及的所有微服务日志消息？
* 如果最终用户开始提交有关响应时间过长的支持案例，如何确定调用链路中哪个微服务导致了延迟？

. 解决方案
+
需要确保所有相关请求和消息都标记有共同的**关联 ID**，并且该**关联 ID**是所有日志事件的一部分。
基于**关联 ID**可以使用集中式日志服务来查找所有相关的日志事件。
如果日志事件包含了**业务相关标识**信息，可以通过**关联 ID** 查找该业务标识符的所有相关日志事件。
+
为了分析协作微服务调用链路中的延迟，必须能够收集请求、响应和消息进入和退出每个微服务的时间戳。

. 解决方案的要求

* 将唯一的**关联 ID** 分配给已知位置中的所有传入或新请求和事件：例如具有标准化名称的标头
* 当微服务发出传出请求或发送消息时，必须将**关联 ID** 添加到请求和消息中
* 所有日志事件必须包含预定义格式的**关联 ID**，以便集中式日志服务可以从日志事件中提取**关联 ID**并使其可搜索
* 必须为请求/响应和消息进/出微服务实例创建跟踪记录

==== 熔断

. 问题
+
使用同步方式通信的微服务系统环境可能面临一系列故障。
如果一个微服务停止响应，其客户端也可能遇到问题，并停止响应来自其客户端的请求。
该问题可以递归地传播到整个环境中。

. 解决方案
+
添加一个——**熔断器**，如果检测到其调用的服务存在问题，则会**阻止调用者发出新的传出请求**。

. 解决方案的要求

* 如果监测到服务问题，则断开连接并快速失败（无需等待超时）
* 探测故障恢复（也称为半开电路），也就是说，允许一个请求定期通过，以查看服务是否再次正常运行
* 如果探测到服务再次正常运行，则关闭熔断。这种能力非常重要，因为它使系统环境对此类问题具有弹性；即它会自动恢复

==== 控制回路

. 问题
+
在一个系统中大量微服务实例分布在多个服务器上的情况下，手动**检测**和**纠正**诸如崩溃或挂起的微服务实例等问题非常困难。

. 解决方案
+
系统环境中添加新组件——**控制回路**。

. 解决方案的要求
+
**控制回路**会不断监控系统环境实际状态，并将其与操作员指定的期望状态进行比较。
如果两种状态不同，它将采取措施使实际状态等于所需状态。
+
在容器化应用部署过程中，通常使用 Kubernetes 等容器编排工具实现此模式。

==== 集中监控与告警

. 问题
+
如果观察到的响应时间和/或硬件资源的使用率高的令人无法接受，则很难发现问题的根本原因。
例如，需要能够分析每个微服务的硬件资源消耗。

. 解决方案
+
添加新组件——**监控服务**，收集微服务系统内每个微服务实例级别的硬件资源使用情况的指标。

. 解决方案的要求

* 必须能够从系统环境使用的所有服务器收集指标，其中包括自动缩放服务器
* 当新的微服务实例在可用服务器上启动时，必须能够检测到它们并开始从中收集指标
* 必须能够提供 API 和图形工具来查询和分析收集到的指标
* 必须能够定义当指定指标超过指定阈值时触发的告警

=== 1.3 软件推动因素

在微服务架构下，有很多非常好的开源工具：

* Spring Boot: 一个应用程序框架
* Spring Cloud/Netflix OSS: 应用程序框架和即用型服务的组合
* Docker: 运行容器工具
* Kubernetes: 容器编排工具
* Istio: 服务网格实现


|===
|设计模式 |Spring Boot |Spring Cloud |Kubernetes |Istio

|服务发现
|
|Netflix Eureka _and_ Spring Cloud LoadBalancer
|Kubernetes `kube-proxy` _and_ service resources
|

|边缘服务器
|
|Spring Cloud Gateway _and_ Spring Security OAuth
|Kubernetes Ingress controller
|Istio ingress gateway

|反应式微服务
|Project Reactor _and_ Spring WebFlux
|
|
|

|配置中心
|
|Spring Config Server
|Kubernetes `Configmaps` _and_ `Secrets`
|

|集中日志分析
|
|
|Elasticsearch, Fluentd _and_ Kibana
|

|分布式追踪
|Micrometer Tracing _and_ Zipkin
|
|
|Jaeger

|熔断
|
|Resilience4j
|
|Outlier detection

|控制回路
|
|
|Kubernetes controller managers
|

|集中监控与告警
|
|
|
|Kiali, Grafana _and_ Prometheus
|===

=== 1.4 其他重要因素

* DevOps 的重要性
* 组织方面与康威定律
* 单体应用分解为微服务
* API 设计的重要性
* 从本地到云的迁移路径
* 微服务的良好设计原则，12因素应用程序(https://12factor.net)

