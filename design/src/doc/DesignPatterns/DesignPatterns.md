# Agile Software Development / DesignPatterns



软件设计的目标：管理**变化**，提高**复用**！

两种手段：**分解**vs.**抽象**

使用了抽象设计原则的面型对象设计最大的优势在于：**抵御变化**！

设计模式的核心：**隔离变化**。将变化带来的影响减为最小。

**对象设计原则**是评判设计模式的**标准**。
设计模式依赖于设计原则。
**设计原则比模式更重要**。

## 拙劣设计的症状

* 僵化性 (Rigidity) ：设计难以改变。
* 脆弱性 (Fragility) ：设计易于遭到破坏。
* 牢固性 (Immobility) ：设计难以重用。
* 粘滞性 (Viscosity) ：难以做正确的事情。
* 不必要的复杂性 (Needless Complexity) ：过分设计。
* 不必要的重复 (Needless Repetition) ：滥用鼠标。
* 晦涩性 (Opacity) ：混乱的表达。

## 面向对象八大设计原则

* 依赖倒置 (DIP)
  
  依赖导致原则几乎贯穿于所有的设计模式。

  * 高层模块（**稳定**）不应该依赖于底层模块（**变化**），二者都应该依赖于抽象（**稳定**）。
  * 抽象（**稳定**）不应该依赖于实现细节（**变化**），实现细节应该依赖于抽象（**稳定**）。
* 开放封闭原则 (OCP)
  * 对**扩展**开放，对**更改**封闭。：
  * 类模块应该是**可扩展**的，但是**不可修改**。
* 单一职责原则 (SRP)
  * 一个类仅有一个引起它变化的原因。
  * 变化的**方向**隐含着类的**职责**。
* Likov 替换原则 (LSP)
  * 子类必须能够**替换**它们的基类(IS-A)。
  * **继承表达类型抽象**。
* 接口隔离原则 (ISP)
  * **不应该强迫客户程序依赖它们不用的方法**。
  * **接口应该小而完备**。
* 优先使用对象**组合**，而不是类继承
  
  继承更多的描述的是**类属**（抽象）关系（例如动物继承自生物，人类继承自动物）。

  * 类继承通常为“**白箱复用**”，对象组合通常为“**黑箱复用**”。
  * 继承在某种程度上破坏了封装性，**子类父类耦合度高**。
  * 而对象**组合**则**只要求被组合的对象具有良好定义的接口**，耦合度低。
  
* 封装变化点
  
  **封装更加高层次的理解是封装变化点**。而不仅仅是编程底层思维上对代码和数据的封装。
  
  * 使用封装来创建对象之间的**分界层**，让设计者可以在分解层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的**松耦合**。
  
* 针对**接口**编程，而不是针对实现编程
  
  即尽量使用**接口**（**抽象**），而不是具体类型（例如使用使用 `List` 而不是 `LinkedList` / `ArrayList` ）。
  于依赖倒置原则相辅相成。是看问题的不同角度（违背了**依赖倒置原则**则违背了**针对接口编程原则**，反之依然）。

  * 不将变量类型声明为某个特定的具体类，而是声明为某个**接口**。
  * 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。
  * 减少系统中各部分的依赖关系，从而实现“**高内聚、松耦合**”的类型设计方案。
  

## 23种常见设计模式：

GOF 23种设计模式分类：

* 从目的来看：
  * 创建型(Creational)模式：
  
      将对象的部分**创建工作**延迟到子类或者其他对象，从而应对**需求变化**为对象创建时**具体类型实现**引来的冲击。
  
  * 结构型(Structural)模式：
  
      通过类继承或对象组合获得更**灵活的结构**，从而应对**需求变化**为**对象的结构**带来的冲击。
  
  * 行为型(Behavioral)模式：
  
      通过类继承或者对象组合来**划分类与对象间的职责**，从而应对需求变化为**多个交互的对象**带来的冲击。

* 从范围来看：
  * **类模式**处理**类与子类的静态关系**。更偏重于继承方案。
  * **对象模式**处理**对象间的动态关系**。更偏重于组合方案。

从**封装变化**角度对模式分类：

* 组件协作：
  
    现代软件专业分工之后的第一个结果是”**框架与应用程序的划分**“、”**组件协作**“模式通过**晚期绑定**，来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式。

  * [Template Method (模板方法)](./组件协作模式/Template%20Method/Template%20Method.md)
  * [Strategy (策略模式)](./组件协作模式/Strategy/Strategy.md)
  * [Observer / Event (观察者模式 / 事件模式)](./组件协作模式/Observer/)
* 单一职责：

    在软件组件的设计中，如果**责任划分**的不清晰，使用**继承**得到的结果往往是随着需求的变化，**子类急剧膨胀**，同时充斥着**重复代码**，这时候的关键是划清**责任**。

  * [Decorator (装饰模式)](./单一职责/Decorator/Decorator.md)
  * [Bridge (桥模式)](./单一职责/Bridge/Bridge.md)
* 对象创建：

    通过**对象创建**模式绕开 `new` ，来避免对象创建( `new` )过程中所导致的紧耦合（**依赖具体类**），从而支持对象创建的**稳定**。它**是接口抽象之后的第一步工作**。

  * [Factory Method (工厂方法)](./对象创建/Factory%20Method/Factory%20Method.md)
  * [Abstract Factory (抽象工厂)](./对象创建/Abstract%20Factory/Abstract%20Factory.md)
  * [Prototype (原型)](./对象创建/Prototype/Prototype.md)
  * [Builder (生成器)](./对象创建/Builder/Builder.md)
* 对象性能：

    面向对象很好地解决了**抽象**的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。

  * [Singleton (单件/单例)](./对象性能/Singleton/Singleton.md)
  * [Flyweight (享元模式)](./对象性能/Flyweight/Flyweight.md)
* 接口隔离：

    在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（**稳定**）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。

  * [Façade (门面模式)](./接口隔离/Façade/Façade.md)
  * [Proxy (代理模式)](./接口隔离/Proxy/Proxy.md)
  * [Adapter (适配器模式)](./接口隔离/Adapter/Adapter.md)
  * [Mediator (中介者模式)](./接口隔离/Mediator/Mediator.md)
* 状态变化：

    在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？**状态变化**模式为这一问题提供了一种解决方案。

  * [State (状态模式)](./状态变化/State/State.md)
  * [Memento (备忘录模式)](./状态变化/Memento/Memento.md)
* 数据结构：
  
    常常有一些组件在内部具有特定的数据结构，如果让客户程序以来这些特定的数据结构，将极大地破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。

  * [Composite (组合模式)](./数据结构/Composite/Composite.md)
  * [Iterator (迭代器)](./数据结构/Iterator/Iterator.md)
  * [Chain of Resposibility (职责链模式)](./数据结构/Chain%20of%20Resposibility/Chain%20of%20Resposibility.md)
* 行为变化：

    在组件的构建过程中，组件行为的变化经常导致**组件本身**剧烈的变化。**行为变化**模式将组件的行为和组件本身进行解耦，从而支持组件行为的变化，实现两者之间的松耦合。

  * [Command (命令模式)](./行为变化/Command/Command.md)
  * [Visitor (访问器模式)](./行为变化/Visitor/Visitor.md)
* 领域问题：

    在特定领域中，某些变化虽然频繁，但可以抽象为某种规则。这时候，结合特定领域，将问题抽象为语法规则，从而给出在该领域下的一般性解决方案。

  * [Interpreter (解析器模式)](./领域问题/Interpreter/Interpreter.md)

## 实践：重构获得模式 Refactoring to Patterns

* 面向对象设计模式是”好的**面向对象设计**“，所谓”好的面向对象设计“指是那些可以满足”**应对变化，提高复用**“的设计。

* 现代软件设计的特征是”需求的频繁变化“。
  设计模式的要点是”寻找**变化点**，然后**在变化点处应用设计模式**，从而来更好地应对需求的变化“。
  ”什么时候、什么地点应用设计模式“ 比 ”理解设计模式结构本身“更为重要。

  > 把软件的**变化**与**稳定**的部分分离开。
  > 
  > **阅读源码同理**。（寻找变化点中的模式）

* 设计模式的应用不宜先入为主，一上来就使用设计模式是对设计模式的最大误用。
  没有一步到位的设计模式。
  敏捷软件开发实践提倡的 `Refactoring to Patterns` 是目前普遍认为的最好的使用设计模式的方法。


### 重构关键技法

* 静态 -> **动态**
* 早绑定 -> **晚绑定**
* 继承 -> **组合**
* 编译时依赖 -> **运行时依赖**
* 紧耦合 -> **松耦合**

## 什么时候不用模式

* 代码可读性很差时
* 需求理解还很浅时
* 变化没有显现时
* 不是系统的关键依赖点
* 项目没有复用价值时
* 项目将要发布时

## 经验之谈

* 不要为模式而模式
* 关注**抽象类** & **接口**
* 理清**变化**点和**稳定**点
* 审视**依赖关系**
* 要有 **Framework** 和 Application 的区隔思维
* 良好的设计是**演化**的结果

## 设计模式成长之路

* **手中无剑，心中无剑**：见模式而不知
* **手中有剑，心中无剑**：可以识别模式，作为应用开发人员使用模式
* **手中有剑，心中有剑**：作为框架开发人员为应用设计某些模式
* **手中无剑，心中有剑**：忘掉模式，只有原则
