# 模型概念

> 模型是对现实的简化。
> 
> 模型是为了能够更好地理解正在开发的系统。
> 
> 因为不能完整地理解一个复杂的系统，所以要对它建模。

通过建模，达到一下4个目的：
1. 模型有助于按照**实际**情况或按照**所需**的样式**对系统进行可视化**。
2. 模型能够**规约系统的结构或行为**。
3. 模型给出了**指导构造系统的模板**。
4. 模型对做出的**决策**进行**文档化**。

## 建模的四项基本原理

* 选择要**创建什么模型**，对**如何动手解决问题**和**如何形成解决方案**有着深远的影响。
  
  > 正确的模型将清楚地表明最棘手的开发问题，提供不能轻易地从别处获得的洞察力；错误的模型将使人误入歧途，把精力花在不相关的问题上。
  > 通过对模型进行严格的持续的实验，将更信任已经建模的系统，事实上，它在现实世界中将像期望的那样工作得很好。
  >
  > 不同的模型将在很大程度上影响对**领域**的看法。
  >
  > 不同的方法将导致不同种类的系统，并且代价和收益也是不同的。

* 可以在不同的**精度级别**上表示每一种模型。

  > 在任何情况下，最好的模型应该是：
  > 它可以让你根据谁在进行观察以及为什么要观察**选择它的详细程度**。

* 最好的模型是**与现实相联系**的。

  > 所有的模型都对现实进行了简化：
  > 诀窍是，确保这种简化不要掩盖掉任何重要的**细节**。
  > 
  > 软件领域中结构化分析的致命弱点是在**分析模型**和**系统设计模型**之间没有基本的联系。
  > 
  > 在面向对象的系统中，可以把各个独立的**系统视图**连接成一个完整的**语义整体**。

* **单个**模型或试图是不充分的。对每个重要的系统最好用一小组**几乎独立的模型**从多个视角去逼近。

  > 在这里的重要短语是**几乎独立的**。
  > 在这个语境中，它意味着各种模型能够被**分别**进行研究和构造，但它们**仍然**是相互**联系**的。
  > 
  > 面向对象的软件系统：
  > 为了理解系统的体系结构，需要几个**互补**和**连锁**的视图。
  > 
  > > 用况视图（揭示系统的需求）、设计视图（捕获问题空间和解空间里的词汇）、交互视图（展示系统各部分之间以及系统与环境之间的联系）、实现视图（描述系统的物理实现）和部署视图（着眼于系统的工程问题）。
  >  
  > 每一种视图都可能有**结构方面**和**行为方面**。
  > 这些视图一起从整体上描绘了软件蓝图。

## 软件建模

软件最普通的两种方法是：

* 从**算法**的角度建模

  **传统**的软件开发从算法角度建模。
  
  > 所有的软件都用**过程**或**函数**作为其主要**构造快**。
  > 
  > 1. 导致开发人员把精力集中于**控制流程**和对大的**算法进行分解**。
  > 2. 常常产生脆弱的系统；当**需求变化**以及**系统增长**时，用这种方法构建的系统会变得**很难维护**
  
* 从**面向对象**的角度建模

  **现代**的软件开发采用**面向对象**的观点进行建模。

  > 所有的软件都用**对象**或**类**作为其主要构造块
  > 
  > > **对象**通常是从**问题空间**或**解空间**的词汇中抽取出来的东西；
  > > **类**是对具有**共同性质**的一组对象（从**建模者**的视角）的描述。
  > > 
  > > 每一个对象都有**标识**（能够对它**命名**，以区别于其他对象）、**状态**（通常有一些**数据**与它相联系）和**行为**（能对该对象**做**某些事情，它也能为其他对象**做**某些事）。

面向对象方法适用于在各种问题域中建造各种**规模**和**复杂度**的系统。

对面向对象系统进行**可视化**、**详述**、**构造**和**文档化**正是统一建模语言 (UML) 的目的。

