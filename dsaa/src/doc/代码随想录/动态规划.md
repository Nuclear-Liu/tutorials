# 动态规划 (Dynamic Programming, DP)


如果某一问题有很多**重叠子问题**，使用动态规划是最有效的。
所以动态规划中**每一个状态一定是由上一个状态推导出来**的，区别于贪心算法，贪心算法没有状态推导，而是从局部直接选最优的；


对于动态规划问题，拆解为如下 5 步，这 5 步搞清楚了，才能算是真正掌握了动态规划：

1. 确定 `dp` 数组(dop table) 以及下标的含义；
2. 确定递推公式；
3. `dp` 数组如何初始化；
4. 确定便利顺序；
5. 举例推导 `dp` 数组；


> **背包问题**
> 
> 有 `N` 件物品和一个最多能背重量为 `W` 的背包。
> 第 `i` 件物品的重量是 `weight[i]` ，得到的价值是 `value[i]` 。
> 每件物品只能用一次，求解将哪些物品添入背包里物品价值总和最大。


一些情况下，递推公式决定了 `dp` 数组的初始化方式。


做动态规划的题目，写好代码之前一定要把状态转移在 `dp` 数组上的具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。


## 斐波那契额数

> 斐波那契数，通常用 `F(n)` 表示，形成的学列称为**斐波那契数列**。
> 该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项的和。
> 
> `F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2);` 其中 `n > 1` 。

### 动态规划 5 步曲

这里要用一个一维数组来保存递归的结果：

1. 确定 `dp` 数组以及下标的含义：
  
  `dp[i]` 的定义为：第 `i` 个数的斐波那契数值是 `dp[i]`

2. 确定递推公式：

  递归公式：状态转移方程： `dp[i] = dp[i - 1] + dp[i - 2]`

3. `dp` 数组如何初始化：

  题目中把如何初始化也直接给出： `dp[0] = 0; dp[1] = 1;`

4. 确定遍历顺序

  递归公式： `dp[i] = dp[i - 1] + dp[i - 2]` ， `dp[i]` 依赖于 `dp[i-1]` 和 `dp[i-2]` ，那么**遍历的顺序**一定是从前到后遍历。

5. 举例推导 `dp` 数组

  按照递归公式，推导当 `n = 10` 时， `dp` 数组应该是： `0 1 1 2 3 5 8 13 21 34 55` 。

## 爬楼梯


> 假设你正在爬楼梯。
> 需要 `n` 阶你才能到达楼顶。
> 
> 每次你可以爬 `1` 或 `2` 个台阶。
> 你有多少种不同的方法可以爬到楼顶呢？（注意：给定 `n` 是一个正整数。）


**思路：**
爬到第一楼有一种方法，爬到二楼有两种方法。
那么第一层再跨两步就到第三层，第二层再夸一步就到第三层。
所以第二层楼梯的状态可以由第二层楼梯和第一层楼梯的状态推导出来，那么就可以想到动态规划。


### 动态规划 5 部曲


定义一个一维数组记录不同楼层的状态：

1. 确定 `dp` 数组以及下标的含义：

  `dp[i]` 爬到第 `i` 层楼梯，有 `dp[i]` 种方法。

2. 确定递推公式：

  从 `dp[i]` 的定义可以看出，每次可以跳一步或者两步， `dp[i]` 可以有两个方向推出来。
  * 首先是 `dp[i - 1]` ，上 `i - 1` 层楼梯，有 `dp[i - 1]` 种方法，那么再一步跳一个台阶就是 `dp[i]` 。
  * `dp[i - 2]` ，上 `i - 2` 层楼梯，有 `dp[i - 2]` 种方法，那么再跳一步跳两个台阶就是 `dp[i]` 。

  所以： `dp[i] = dp[i - 1] + dp[i - 2]`

  > 推导 `dp[i]` 的时候，一定要时刻想着 `dp[i]` 的定义，否则容易跑偏。

3. `dp` 数组如何初始化：

  题目中 `n` 正整数，题目根本没有 `n` 为 `0` 的情况。
  所以不需要讨论 `dp[0]` 的初始化。

  对于 `dp[1] = 1` `dp[2] = 2` 是显而易见的。（一层台阶和两层台阶）

4. 确定遍历顺序：

  递推公式： `dp[i] = dp[i - 1] + dp[i - 2]`

5. 举例推导 `dp` 数组：

  当 `n = 5` 的时候， `dp` 数组： `1 2 3 5 8`

> 与**斐波那契数列**的区别是没有讨论 `dp[0]` （当前问题没有意义）的问题。


### 拓展


这道题目可以继续深入，即：一步一个调节，两个台阶，三个台阶，直到 `m` 个台阶，有多少种方法爬到 `n` 阶楼顶。


```text
for (int i = 1; i <=n; i++) {
    for(int j = 1; j <= m; j++) {
        if(i - j >= 0) 
            dp[i] += dp[i - j];
    }

}
```


## 使用最小花费爬楼梯


> 数组的每个下标作为一个阶梯，第 `i` 个阶梯对应着一个非负数的体力花费值 `cost[i]` （下标从 `0` 开始）。
> 
> 
> 每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。
> 
> 
> 请你找出达到楼层顶部的最低花费。
> 在开始时，你可以选择从下标 `0` 或 `1` 的元素作为初始阶梯。


