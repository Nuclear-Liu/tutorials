## 实现泛型构建 pre-Java 5

> Java 中如何使用继承的基本原则来实现一些**泛型方法和类**。

在 1.5 版本以前， Java 并不直接支持泛型实现，泛型编程的实现是通过使用**继承**的一些概念来完成的。

### 使用 `Object` 表示泛型


Java 中的基本思想是通过使用 `Object` 这样适当的超类实现泛型类。
使用这种策略时，有两个细节必须考虑：


* 为了访问对象的一个特定方法，必须**强制转换**成正确的类。
* 引用的类型能够与 `Object` 相容（不能是基本类型，基本类型需要使用对应的**包装类**）。


> **基本类型的包装**
> 
> **包装类**(wrapper class) 是存储一个基本的类型，并添加一些这种类型不支持或不能正确支持的操作。
> 
> Java 为 8 种基本类型种的每一种提供了对应的包装类。
> 每一个包装类对象都是**不可变的**（就是说它的状态绝对不能改变），它存储一种当给对象被构建时所设置的**原值**，并提供一种方法以重新得到给之。

### 使用接口类型表示泛型

> 只有在使用 `Object` 类中已有的那些方法能够表示**所执行的操作**的时候，才能使用 `Object` 作为泛型类型来工作。

考虑在由一些项组成的数组中找出最大项的问题。基本的代码是类型无关的，但是它的确需要一种能力( `Comparable` 接口 )来比较任意两个对象。


> **提示**
> 
> * 只有实现了 `Comparable` 接口的对象才能够作为 `Comparable` 数组的元素被传递。
> * 如果 `Comparable` 数组有两个不相容对象， `compareTo()` 方法将抛出 `ClassCastException` 异常。这是**期望的行为**。
> * 基本类型包装类实现了 `Comparable` 接口，可以作为 `Comparable` 传递；基本类型不能作为 `Comparable` 传递。
> * 接口是否是标准的库接口不是必需的。
> * 此方案不是总能行得通，有时宣称一个类实现所需的接口是不可能的（库中的类、 `final` 类）。


> **数组类型的兼容性**
> 
> 假设 `Employee` _IS-A_ `Person` `Student` _IS-A_ `Person`
> 
> `Person[] p = new Employee[5]; # p are compatible `
> 
> `p[0] = new Student(); # Student IS-A Person `
> 
> `p[0]` 实际引用 `Employee` ，可是 `Student` IS-NOT-A `Employee` 。
> 这产生了类型混乱。
> 
> 运行时系统(runtime system)不能抛出 `ClassCastException` 异常，因为此时不存在类型转换。
> 
> 避免这种问题的最容易的方法是指定这些数组不是类型兼容的。
> 在 Java 中数组却是**类型兼容**的。这叫做**协变数组类型**(covariant array type)。
