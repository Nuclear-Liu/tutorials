# Electron

页面加载进应用窗口中，需要两个 Electron 模块：

* `app` 控制应用程序的**事件声明周期**
* `BrowserWindow` 创建和管理**应用程序窗口**

在 Electron 中，只有在 `app` 模块的 `ready` 事件被激发后才能创建浏览器窗口；
通过使用 `app.whenReady()` API 来监听事件， 在 `whenReady()` 成功后调用**创建浏览器窗口实例(createWindow)**`


> Electron 遵循 JavaScript 传统约定：
> * 以 **PascalCase** 命名可实例化的类（如： `BrowserWindow` `Tray` `Notification` ）
> * 以 **camelCase** 命名不可实例化的函数、变量等（如： `app` `ipcRenderer` `webContents` ）

Electron 很多核心模块是 Node.js **事件触发器**，遵守 Node.js 的异步事件驱动架构(`app` 就是其中一个)。


应用中的每个页面都是在一个单独的进程中运行，称这些进程为 **渲染器**(_renderer_)。


Electron 程序运行在 `package.json` 文件的 `main` 字段设置的入口文件；
这个入口文件控制着 Electron 的**主进程**；
主进程运行于 Node.js 实例，负责**应用的生命周期**、**展示原生窗口**、**执行特殊操作**、**管理渲染进程**。

## 管理应用的窗口声明周期

应用窗口在不同的系统中的行为不用；
Electron 允许通过监听 `app` 和 `BrowserWindow` 模块组件，自行实现这些行为来遵循操作系统的规范

## 预加载脚本

预加载脚本在浏览器窗口加载网页之前运行的代码；
可以访问 DOM 接口和 Node.js 环境，在其中使用 `contextBridge` 接口将特权接口暴露给渲染器。

* `contextBridge` 安全的将特权 API 暴露至渲染进程中
* 使用 Electron 进程间通信(IPC) 模块让**主进程**与**渲染进程**进行通信


Electron **主进程**拥有完全操作系统范文权限的 Node.js 环境。
Electron **渲染进程**运行在网页页面上，而非 Node.js 。

### 1. 增强渲染器

### 2. 进程间通信(IPC)


## `app` 模块

### `app`:`ready` 事件

`ready` 事件出发后才能创建 `BrowserWindows` 实例；
可以借助 `app.whenReady()` API 来等待事件完成

> `app.whenReady()` 替代 `app.on('ready')` 监听，避免 `on` 事件带来的问题。
