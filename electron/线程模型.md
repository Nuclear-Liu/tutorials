# 线程模型

Electron 继承自 Chromium 的多线程架构，在架构上非常相似于一个现代网页浏览器。

> Chrome 团队让**每个标签页在自己的进程中渲染**，限制了一个页面上的有误或恶意代码可能导致的对整个应用程序的伤害，用**单个浏览器进程控制这些标签页进程，以及整个应用程序的生命周期**。
> 
> Electron 应用分为两种类型的进程： **主进程** 和 **渲染器进程** （类似于 Chrome 的**浏览器**和**渲染器**进程）

## 主进程

每个 Electron 应用都有一个唯一的**主线程**作为应用程序的入口点。

**主进程**在 Node.js 环境中运行，所以它具有 `require` 模块和使用所有 Node.js API 的能力。
负责**应用的生命周期**、**展示原生窗口**、**执行特殊操作**、**管理渲染进程**。

### 窗口管理

**主进程**通过使用 `BrowserWindow` 模块创建和管理应用程序窗口。

`BrowserWindow` 类的每个实例创建一个应用程序窗口，且在单独的渲染器进程中加载一个网页。
主进程中通过 `BrowserWindow` 实例的 `webContents` 对象于页面内容进行交互。

**当 `BrowserWindow` 实例被销毁时，相应的渲染器进程也会被终止**。

> **注意：**
> 
> `web embeds` 嵌入式页面将会被创建一个渲染器进程，例如： `BrowserView` 模块。
> 对于嵌入式 Web 内容也可以访问 `webContents` 对象。

### 应用程序生命周期

**主进程**通过 Electron 的 `app` 模块来控制应用程序的生命周期。

`app` 模块提供了一整套的事件和方法，可以让您用来添加自定义应用程序行为（应用退出、程序坞、关于面板）。

### 原生 API

**主进程**包含自定义的 API 来于用户作用系统进行交互。
**主进程**有多种控制原生桌面功能的模块（**菜单**、**对话框**、**托盘图标**）

## 渲染器进程

Electron 应用会为每个打开的 `BrowserWindow` (包括 `web embeds`) 生成一个单独的渲染器进程，负责渲染页面内容。
渲染器进程中的代码须遵循网页标准（与网页开发上使用相同的工具和规范编写）

* 以一个 HTML 文件作为渲染器进程的入口点
* 使用 CSS 对 UI 添加样式
* 通过 `<script>` 元素添加可执行的 JavaScript 代码

**渲染器进程无权直接访问 `require` 或 Node.js API**

## Preload 脚本

预加载 `preload` 脚本包含在渲染进程中执行的代码，先于网页内容加载。
脚本运行于渲染器上下文中，但是可以访问 Node.js API 。

通过 `BrowserWindow` 构造方法中的 `webPreferences`:`preload` 附加到主进程。

```js
const win = new BrowserWindow({
  webPreferences: {
    preload: '<preload.js>',
  },
})
```

**预加载脚本与浏览器共享同一个全局 `Window` 接口，并且可以访问 Node.js API，但是因为默认的上下文隔离(`contextIsolation`)，并不能直接附加任何变动到 `window` 上**。
使用 `contextBridge` 模块安全地实现交互。


* 暴露 `ipcRenderer` 用于**主进程**与**渲染进程**进程间通信
* 如果为远程 URL 上托管现有 Web 应用，则可以在渲染器的 `window` 全局变量上添加自定义属性，使得 Web 适用于桌面应用的设计逻辑
