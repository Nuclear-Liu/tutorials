# 并发编程三大特性

## 可见性(`visibility`)

默认情况下一个线程改变一个变量值，另一个线程看不到最新的值；
可见性是线程之间的缓存（不是 Thread Local ）互相之间保持数据一致性（线程缓存与内存中数据保持同步）的一种机制；

* 通过关键字 `volatile` 关键字修饰变量可以使的变量线程间可见；

    `volatile` 修饰引用类型（包括数组）只能保证引用本身的可见性，不能保证内部字段的可见性；
    `volatile` 还可以禁止指令重排序；

* 线程之间一些**语句**会触发内存缓存同步刷新（存在同步 `synchronized` 等关键字）；


> 每个线程运行时，会把变量拷贝一份放在线程自己的缓存；每次读取数据读取的时线程的缓存，不会在重新读；


| CPU 计算单元 ALU 访问： | 速度       |
|------------------|----------|
| Registers        | `1< ns`  |
| L1 cache         | 约 `1ns`  |
| L2 cache         | 约 `3ns`  |
| L3 cache         | 约 `15ns` |
| main memory      | 约 `80ns` |


> **缓存行（Cache Line(64 Byte)）**
> 
> 为了缓存效率更高，根据程序的局部性原理（空间局部性），缓存是按照相邻区域的内存进行缓存（缓存行）；
> 
> 时间局部性原理是指令的缓存，空间局部性原理是数据的缓存；
> 
> 缓存行越大，局部性空间效率越高，读取时间慢；
> 缓存行越小，局部性空间效率越低，读取时间快；
> 通过普遍的工业实践，目前缓存行大小为 `64 Byte` ；

> **缓存一致性**
> 
> MESI Cache 一致性协议是缓存一致性协议的一种（MOSI等）；
> MESI 将缓存行 (Cache Line) 标记为四种状态： `Modified` `Exclusive` `Shared` `Invalid` ；主动进行数据更新；
> 
> `volatile` 低层与 `MESI` 无关；
> 
> 如果变量位于同一行，需要缓存一致性协议保持行内数据的一致，导致效率下降；
> 
> `@Contended` : 保证数据与其他数据不会唯一同一缓存行（仅在 1.8 版本 JDK 可用）； 
> 注解生效需要修改 JVM 运行参数： `-XX:-RestrictContended` 注解才可以生效；

## 有序性(`ordering`)

计算机内存在指令重排序，以提高效率；

乱序执行的**原则**：

* as - if - serial **不影响单线程的最终一致性**

    看上去是序列化执行的，实际上**不影响线程最终一致性**，并不一定顺序执行；

> `this` 对象逸出，所以不要在构造方法中启动线程。


> 美团面试：关于 `Object o = new Object();`
> 
> 1. 请解释以下对象的创建过程？（半初始化）
> 
>     ```text
>     0 new #2 <java/lang/Object>
>     3 dup
>     4 invokespecial #1 <java/lang/Object.<init> : ()V>
>     7 astore_1
>     8 return
>     ```
>     
>     核心代码： `0` `4` `7`
>     
>     `0` 执行后对象处于半初始化状态，属性为默认值；执行完 `4` 对象完成初始化； `7` 将对象与 `this` 建立关联；
> 
>     对象的**引用**存在于**运行的线程栈栈帧**中；
> 
> 2. 加问 `DCL` 与 `volatile` 问题？（指令重排）
> 
>     > `DCL` Double Checked Locking 双重检查锁；（单例模式）
>     
>     `volatile` : 线程可见、禁止指令重排；
> 
>     必须要加 `volatile` 修饰单例对象的引用；
>     因为存在半初始化和指令重排，并发情况下获得锁的线程如果发生了指令重排序，首先建立关联 `7` 在对象初始化 `4` 之前，此时对象引用存在，不再为 `null` 此时其他线程获取到的单例对象不为空但是是半初始化状态的对象；
> 
> 3. 对象在内存中的布局问题？（对象与数组的存储不用）
> 
>     hotspot 中使用（C++实现） `oopDesc` 数据结构代表一个 Java 对象；
> 
>     * **普通对象**由四部分构成： `markword` 标记字、 `klass pointer` 类型指针（指向 `*.class` ，对象在内存中的类型Class对象地址）、 `instance data` 实例数据、 `padding` 对齐
>     * **数组对象**由五部分构成： `markword` 标记字、 `klass pointer` 类型指针（指向 `*.class` ，数组类型在内存中类型Class对象地址）、 `length`(4Byte) 数组 长度、 `instance data` 实例数据、 `padding` 对齐
> 
> 4. 对象头具体包括什么（ `markword` `klasspointer` `synchronized` 锁信息）
> 
>     对象头包括两部分： `markword` `class pointer`
> 
>     ```text
>     java.lang.Object object internals:
>      OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
>           0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)
>           4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
>           8     4        (object header)                           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)
>          12     4        (loss due to the next object alignment)
>     Instance size: 16 bytes
>     Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
>     ```
> 
>     * `markword`: `[0, 8)Byte`
>         * 锁信息
>         * `hashCode` ： Identity Hashcode(是独一无二的 hashCode)
>         * gc 信息
>     * `klass pointer` `[8, 12)Byte`
> 
> 5. 对象怎么定位（直接  间接）
> 
>     * 直接指针 （hotspot 实现方式；优点：直接访问；缺点：GC需要移动对象的时候麻烦；）
>    
>         引用直接**指向实例化对象（堆）**，实例化对象包含**类型指针（方法区）**；
>     * 句柄方式 （优点：对象体积小，垃圾回收时不用频繁改动引用本身；缺点：两次访问；）
>         
>         引用指向一个包含实例数据指针（指向堆空间实际对象）和类型指针（指向方法区）的结构体（堆）
> 
> 6. 对象怎么分配？（栈上-线程本地-Edon-Old）
> 
>     > 多个线程相同一块内存空间分配对象需要经历**同步sync**的过程；
>     > TLAB： 线程启动时在线程Edon中分配一块线程独占区域（空间比较小）；
> 
>     * 首先尝试在**栈**上分配（栈帧弹出自动清理对象，不需要垃圾回收机制，效率极高）；
>         * 对象需要符合：逃逸分析
>         * 对象需要符合：标量替换
>     * 如果体积够大，分配在 Old 老年代（通过 `FGC` 实现对象回收）；
>     * 否则在 TLAB(Thread Local Allocation Buffer, 线程本地分配缓冲区) 中分配；
>     * 如果 TLAB 分配不下分配在 Edon 区（经过GC清理，如果回收释放内存，没有回收放入 S1 ，之后再经过GC清理年龄够了进入 Old 老年代，不够进入 S2，S2再经过GC清理）；
> 
>     > 每次回收一次，年龄增加一次；
> 
> 7. Object o = new Object() 在内存中占用多少字节？
> 
>     （20Byte） 看内存压缩是否开启，内存是否超过32GB；
> 
> 8. 为什么 hotspot 不使用 C++ 对象来代表 Java 对象？
> 
>     C++ 中存在 Virtual Table Pointer 如果每个 Java 对象都有浪费空间；
> 
>     Java 中使用 oop-klass 二元机制；
> 
>     > `new T();` 时首先生成一个 `T.class` C++ 对象(`instanceklass`)（如果已经存在，不会再次生成）；加上 oop 数据结构构成 oop-klass 二元机制；
> 
> 9. Class 对象是在堆还是在方法区？
> 
>     方法区；
> 
>     栈(stack) 存储对象引用；对象本身在（heap）；对象上的 klass （instanceClassOop）（C++对象）在方法区；`instanceClassOop` 中的存在一个指针，指向（heap）中的类对象(`*.class`)（用于反射）；


## 原子性(`atomicity`)

