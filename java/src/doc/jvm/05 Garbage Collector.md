# Garbage Collector(GC) _垃圾回收器_

Java GC 自动垃圾回收，开发效率高，执行效率相对低；

## Garbage _垃圾_

没有被引用的对象归为**垃圾**(Garbage)；

## 定位 Garbage 算法

* reference count _引用计数_

    引用计数不能处理**循环引用**；

* root searching _根可达_

    GC `roots` (根对象): 线程栈变量、静态变量、常量池、 `JNI` 指针 (GC `roots` : JVM stack, native method stack, run-time-constant pool, static references in method area, Clazz)

## 清理 Garbage 算法

* mark-sweep _标记清除_

    通过 `root searching` 根可达算法，将垃圾做标记，然后清除释放空间；

    > **优点**：
    > 
    > * 算法相对简单，存活对象比较多的情况下（清理的对象少）效率比较高；
    > 
    > **缺点**：
    > 
    > * 两遍扫描（第一遍（**标记**）根据**根可达算法**确定不可回收对象内存，第二遍（**清除**）在第一遍的基础上确定可回收对象）效率偏低；
    > * 容易产生碎片；

* copying _拷贝_

    将不可回收对象移动拷贝在到一块新的区域，逻辑上分成两块内存区域（在垃圾回收前占用的空间和垃圾回收后存放拷贝的不可回收对象的区域），清理过程直接释放掉整个旧的内存区域；

    > **优点**：
    > 
    > * 适用于存活对象较少的情况，只扫描一次，效率提高，没有内存碎片；
    > 
    > **缺点**：
    > 
    > * 空间浪费（需要将当前内存中的不可回收对象拷贝到一块新的内存区域）；
    > * 移动空间，调整对象引用；

* mark-compact _标记压缩_

    将存活对象整理到内存区域的一端；

    > **优点**：
    >
    > * 不会产生碎片，方便对象分配；
    > * 不会产生可用内存减半；
    >
    > **缺点**：
    >
    > * 扫描两次；
    > * 需要移动对象，效率偏低；

## 堆内存逻辑分区

**不适用不分代垃圾收集器**；

> Hotspot 内部使用的是**分代算法**；

> 除 `Epsilon` `ZGC` `Shenandoah` 之外的 GC 都是使用逻辑分代模型；
> 
> `G1` 仅实现了逻辑分代；
> 其他 GC 不仅逻辑分代，并且物理分代；

### 逻辑分代模型

> 除了 `G1` 的其他逻辑分代模型 GC 默认： `new/young : old/tenured = 1 : 2`

新生代对象大量死去，少量存活，适合**复制算法**；
老年代存活率高，回收较少，适合**标记清除**或者**标记压缩**；

* `new` / `young`: `1` _新生代_ **Coping**

    实例化的新对象，首先位于**新生代**；
    * `eden`: `8` _伊甸_
        
        实例化对象栈 stack 上分配不下时，分配到当前区域；

    * `survivor`: `1`

        `eden` 中对象经过一次 `GC` 没有被回收，归属到当前区域；

    * `survivor`: `1`

        `servivor` 1 区中的对象经过一次 `GC` 没有被回收，归属到当前区域；

    > `servivor` 两个区中对象进入 `old` 区的年龄通过参数： `--XX:MaxTenuringThreshold` 配置

* `old` / `tenured`: `2` _老年代_ **mark-sweep**/**mark-compact**

    经过多次 GC 没有被回收的对象位于**老年代**；

> `MinorGC`/`YGC`: 年轻代空间耗尽是触发的 GC ；
> 
> `MajorGC`/`FullGC`: 老年代空间耗尽时触发，新生代、老年代同时 GC ；

> 年轻代空间大小控制参数： `-Xmn`
> 
> 老年代空间大小控制参数： `-Xms` `-Xmx`

## GC tuning _GC 调优_
