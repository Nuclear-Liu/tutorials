# CMS (ConcurrentMarkSweep) _并发标记清除_

## CMS 阶段

1. `initial mark` 初始标记(STW)（单线程），指标及根对象

    根据根可达算法，扫面跟对象（线程栈变量、静态变量、常量池、JNI指针）；只需要找到根对象，所以 STW 时间比较短；

2. `concurrent mark` 并发标记（多线程），于应用程序同时运行

    （最耗时的阶段，不产生 STW）在阶段一的基础上

3. `remark` 重新标记(STW)（多线程），多是已经并发标记完成，对新产生的垃圾进行标记

    需要重新标记的数量相对较少，所以 STW 停顿时间比较短；

4. `concurrent sweep` 并发清理，清理过程也会产生新的垃圾，这种叫做**浮动垃圾**，需要下次CMS运行的时候进行清理；

# [G1 (Garbage First)](https://www.oracle.com/technical-resources/articles/java/g1gc.html)

> 计算机领域重要思想： **分而治之**、**分层**

Garbage First Garbage Collector (G1 GC) 是适用于 Java HotSpot VM 的**低暂停**、服务器风格的分代式垃圾回收器。
G1 GC 使用并发和并行阶段实现其目标暂停时间，并保持良好的吞吐量。
当 G1 GC 确定有必要进行垃圾回收时，它会**先收集存活数据最少的区域**（**垃圾优先**）。

G1 中将内存划分为大小不同的 `Region` 进行管理；
`Region` 从 `1M` 开始最大 `32M` （按照2的幂次一次底层）；
每一个 `Region` 在逻辑上依然分代不同的代；

**压缩机制**：G1 是一种带压缩的收集器，在回收老年代的 `Region` 时，可以将存活对象从一个 `Region` 拷贝到另一个 `Region` ，拷贝的过程实现了局部的压缩。

> **G1 代体系**：
> 
> * `eden`
> * `servivor`
> * `old`
> * `humongous` 大对象区（可能包含多个连续区域的 `region` ）
>
> **新生代**中的对象，要么被**回**收、要么**晋升**，至于新生代也采取分区机制的原因，则是因为与老年代的策略统一，方便调整代的大小。

GC 特点：
* 并发收集
* 压缩空闲空间不会延长 GC 的暂停时间
* 更易预测的 GC 暂停时间
* 适用不需要实现很高的吞吐量的场景

### 基本概念

* `CSet` Collection Set

> **颜色指针**
> 
> 在对象引用的 64位 地址中最高的 3 个 Bite 进行颜色标记；
> 当对象的引用发生改变进行颜色标记；
> 
> **三色扫描算法**
>     * 黑 自己已经标记， `fields` 都标记完成
>     * 白 自己已经标记， `fields` 还未来得及标记
>     * 灰 没有遍历到的节点
> 
>     > 在并发标记时，引用可能产生变化，白色对象有可能被错误回收；
> 
>  **SATB(Snapshot At The Beginning)**
>     *
> 
>  **IncrementalUpdate**

