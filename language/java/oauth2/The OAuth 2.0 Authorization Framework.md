# The OAuth 2.0 Authorization Framework

## 摘要

OAuth 2.0 授权框架通过协调资源所有者和 HTTP 服务之间的审批交互，或者通过允许第三方应用以自己的名义获取访问权，是第三方应用能够代表资源所有者获取对 HTTP 服务的有限访问权限。
本规范取代并废止了 RFC 5849 中描述的 OAuth 1.0 协议。

> **本备忘录的状态**
> 
> 这是一份互联网标准跟踪文件。
> 
> 本文档是互联网工程任务组 (IETF) 的产品。
> 它代表了 IETF 社区的共识。
> 它已接受公众审查，并由互联网工程指导小组 (IESG) 批准发布。
> 有关互联网标准的更多信息，请参见 RFC 5741 的第 2 部分。
> 
> 有关本文档的当前状态、任何勘误以及如何提供反馈的信息，请访问 http://www.rfc-editor.org/info/rfc6749 。

**版权声明**

版权所有 (c) 2012 IETF Trust 和文档作者。
保留所有权利。

本文档受 BCP 78 和 IETF Trust 的《与 IETF 文档有关的法律规定》(http://trustee.ietf.org/license-info) 的约束，在本文档发布之日有效。
请仔细阅读这些文件，因为它们描述了您对本文档的权利和限制。
从本文档中提取的代码组件必须包含信托法律条款第 4e 节所述的简化 BSD 许可文本，并且按照简化 BSD 许可中的描述，不提供担保。

## 1. Introduction 简介

在传统的**客户端**-**服务器**认证模式中，客户端通过使用**资源所有者**的凭证向服务器进行认证，从而请求服务器上的访问受限资源（受保护资源）。
为了让第三方应用程序访问受限资源，资源所有者与第三方共享其凭证。
这就产生了一些问题和限制：

* **第三方应用程序**需要存储**资源所有者的凭证**以供将来使用，通常是**明文密码**。
* 要求服务器支持密码验证，尽管密码中存在固有的安全弱点。
* 第三方应用程序对资源所有者受保护资源的访问**范围过于广泛**，导致资源所有者无法限制资源的使用**期限**或对有限资源子集的访问。
* 任何第三方应用程序的**破坏**会导致最终用户的密码和受该密码保护的所有数据的损坏。

OAuth 通过引入**授权层**和分离**客户端**与**资源所有者**的**角色**来解决这些问题。
在 OAuth 中，_客户端请求访问由资源所有者实际控制并由资源服务器**托管**的资源，并获得一组与资源所有者不同的**凭证**_。

客户端不使用资源所有者的凭证访问受保护的资源，而是获得一个**访问令牌**——一个表示特定**范围**、**有效期**和**其他访问属性**的字符串。
**访问令牌**由**授权服务器**经资源所有者批准后发放给第三方客户端。
客户端使用访问令牌访问资源服务器托管的受保护资源。

例如，终端用户（**资源所有者**）可以授权打印服务（**客户端**）访问其存储在照片共享服务（**资源服务器**）中的受保护照片，而无需与打印服务共享其用户名和密码。
相反，它直接向照片共享服务所信任的服务器（**授权服务器**）进行身份验证，由该服务器向打印服务器颁发特定于授权的凭证（**访问令牌**）。

本规范设计用于 HTTP(RFC 2616) 。
在 HTTP 以外的任何协议使用 OAuth 都超出了范围。

OAuth 1.0 协议 (RFC 5849) 作为信息文档发布，是一个小型特设社区努力的结果。
本标准跟踪规范基于 OAuth 1.0 的部署经验，以及从更广泛的 IETF 社区收集的附加用例和可扩展性要求。
OAuth 2.0 协议与 OAuth 1.0 不向后兼容。
这两个版本可以在网络上并存，实现者可以选择同事支持这两个版本。
但是，本规范希望最新的实现能够支持文档中规定的 OAuth 2.0 ，而 OAuth 1.0 仅用于支持现有部署。
OAuth 2.0 协议与 OAuth 1.0 协议共享的实现细节很少。
熟悉 OAuth 1.0 的实施者在使用本文档时，不应对其结构和细节做任何假设。

### 1.1. Roles 角色

OAuth 定义了四个角色：

* 资源所有者(**resource owner**)

    能够授予对受保护资源的访问权限的**实体**。当资源所有者是个人时，它被称为**最终用户**。

* 资源服务器(**resource server**)

    **托管保护资源的服务器**，能够**使用访问令牌接受和响应受保护资源请求**。

* 客户端(**client**)

    代表资源所有者并经其授权**发出受保护资源请求的应用程序**。”客户端“一次并不意味着任何特定的实现特征（例如，应用程序是否在服务器、桌面或其他设备上执行）。

* 授权服务器(**authorization server**)

    在成功验证资源所有者身份并获得授权后，向客户端**发放访问令牌的服务器**。

**授权服务器**和**资源服务器**之间的交互超出了本规范的范围。
授权服务器可以是与资源服务器相同的服务器，也可以是单独的实体。
单个授权服务器可发出多个资源服务器接受的访问令牌。

### 1.2. Protocol Flow 协议流程

```text
     +--------+                               +---------------+
     |        |--(A)- Authorization Request ->|   Resource    |
     |        |                               |     Owner     |
     |        |<-(B)-- Authorization Grant ---|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(C)-- Authorization Grant -->| Authorization |
     | Client |                               |     Server    |
     |        |<-(D)----- Access Token -------|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------>|    Resource   |
     |        |                               |     Server    |
     |        |<-(F)--- Protected Resource ---|               |
     +--------+                               +---------------+

                     Figure 1: Abstract Protocol Flow _抽象协议流程_
```

图 1 所示的抽象 OAuth 2.0 流程描述了四个角色之间的交互，包括以下步骤：

* (A) **客户端**向**资源所有者**请求授权。授权请求可以直接向资源所有者提出（如图所示），也可以通过**授权服务器**作为中介间接提出。
* (B) **客户端**收到**授权许可**，它是**代表资源所有者授权的凭证**，使用本规范定义的四种许可类型之一或扩展许可类型表示。授权授予类型取决于客户机用于请求授权的方法和授权服务器支持的类型。
* (C) **客户端**通过对**授权服务器**进行**身份验证**并提交**授权许可**来**请求访问令牌**。
* (D) **授权服务器**对**客户端**进行身份验证并验证授权许可，如果有效，则签发访问令牌。
* (E) **客户端**向**资源服务器**请求受保护的资源，并通过出示访问令牌进行身份验证。
* (F) **资源服务器**验证访问令牌，如果有效，则为请求提供服务。

**客户端**从**资源所有者**处获取授权许可的首选方法（如步骤 `(A)` 和步骤 `(B)` 所示）是使用**授权服务器**作为中介，如第 4.1 节中的图 3 所示。

### 1.3. Authorization Grant 授权许可

**授权许可**是代表资源所有者**授权**（访问其受保护资源）的凭证，客户端使用它来获取访问令牌。
本规范定义了四种授权类型—— **授权码**(`authorization code`)、**隐式**(`implicit`)、**资源所有者密码凭证**(`resource owner password credentials`)、**客户端凭证**(`client credentials`) —— 以及一种用于定义其他类型的扩展机制

#### 1.3.1. Authorization Code 授权码

#### 1.3.2. Implicit 隐式

#### 1.3.3. Resource Owner Password Credentials 资源所有者密码凭证

#### 1.3.4. Client Credentials 客户端凭证

### 1.4. Access Token

### 1.5. Refresh Token

### 1.6. TLS Version

### 1.7. HTTP Redirections

### 1.8. Interoperability

### 1.9. Notational Conventions

## 2. Client Registration

