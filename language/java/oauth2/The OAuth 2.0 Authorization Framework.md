# The OAuth 2.0 Authorization Framework

## 摘要

OAuth 2.0 授权框架通过协调资源所有者和 HTTP 服务之间的审批交互，或者通过允许第三方应用以自己的名义获取访问权，是第三方应用能够代表资源所有者获取对 HTTP 服务的有限访问权限。
本规范取代并废止了 RFC 5849 中描述的 OAuth 1.0 协议。

> **本备忘录的状态**
> 
> 这是一份互联网标准跟踪文件。
> 
> 本文档是互联网工程任务组 (IETF) 的产品。
> 它代表了 IETF 社区的共识。
> 它已接受公众审查，并由互联网工程指导小组 (IESG) 批准发布。
> 有关互联网标准的更多信息，请参见 RFC 5741 的第 2 部分。
> 
> 有关本文档的当前状态、任何勘误以及如何提供反馈的信息，请访问 http://www.rfc-editor.org/info/rfc6749 。

**版权声明**

版权所有 (c) 2012 IETF Trust 和文档作者。
保留所有权利。

本文档受 BCP 78 和 IETF Trust 的《与 IETF 文档有关的法律规定》(http://trustee.ietf.org/license-info) 的约束，在本文档发布之日有效。
请仔细阅读这些文件，因为它们描述了您对本文档的权利和限制。
从本文档中提取的代码组件必须包含信托法律条款第 4e 节所述的简化 BSD 许可文本，并且按照简化 BSD 许可中的描述，不提供担保。

## 1. Introduction 简介

在传统的**客户端**-**服务器**认证模式中，客户端通过使用**资源所有者**的凭证向服务器进行认证，从而请求服务器上的访问受限资源（受保护资源）。
为了让第三方应用程序访问受限资源，资源所有者与第三方共享其凭证。
这就产生了一些问题和限制：

* **第三方应用程序**需要存储**资源所有者的凭证**以供将来使用，通常是**明文密码**。
* 要求服务器支持密码验证，尽管密码中存在固有的安全弱点。
* 第三方应用程序对资源所有者受保护资源的访问**范围过于广泛**，导致资源所有者无法限制资源的使用**期限**或对有限资源子集的访问。
* 任何第三方应用程序的**破坏**会导致最终用户的密码和受该密码保护的所有数据的损坏。

OAuth 通过引入**授权层**和分离**客户端**与**资源所有者**的**角色**来解决这些问题。
在 OAuth 中，_客户端请求访问由资源所有者实际控制并由资源服务器**托管**的资源，并获得一组与资源所有者不同的**凭证**_。

客户端不使用资源所有者的凭证访问受保护的资源，而是获得一个**访问令牌**——一个表示特定**范围**、**有效期**和**其他访问属性**的字符串。
**访问令牌**由**授权服务器**经资源所有者批准后发放给第三方客户端。
客户端使用访问令牌访问资源服务器托管的受保护资源。

例如，终端用户（**资源所有者**）可以授权打印服务（**客户端**）访问其存储在照片共享服务（**资源服务器**）中的受保护照片，而无需与打印服务共享其用户名和密码。
相反，它直接向照片共享服务所信任的服务器（**授权服务器**）进行身份验证，由该服务器向打印服务器颁发特定于授权的凭证（**访问令牌**）。

本规范设计用于 HTTP(RFC 2616) 。
在 HTTP 以外的任何协议使用 OAuth 都超出了范围。

OAuth 1.0 协议 (RFC 5849) 作为信息文档发布，是一个小型特设社区努力的结果。
本标准跟踪规范基于 OAuth 1.0 的部署经验，以及从更广泛的 IETF 社区收集的附加用例和可扩展性要求。
OAuth 2.0 协议与 OAuth 1.0 不向后兼容。
这两个版本可以在网络上并存，实现者可以选择同事支持这两个版本。
但是，本规范希望最新的实现能够支持文档中规定的 OAuth 2.0 ，而 OAuth 1.0 仅用于支持现有部署。
OAuth 2.0 协议与 OAuth 1.0 协议共享的实现细节很少。
熟悉 OAuth 1.0 的实施者在使用本文档时，不应对其结构和细节做任何假设。

### 1.1. Roles 角色

OAuth 定义了四个角色：

* 资源所有者(**resource owner**)

    能够授予对受保护资源的访问权限的**实体**。当资源所有者是个人时，它被称为**最终用户**。

* 资源服务器(**resource server**)

    **托管保护资源的服务器**，能够**使用访问令牌接受和响应受保护资源请求**。

* 客户端(**client**)

    代表资源所有者并经其授权**发出受保护资源请求的应用程序**。”客户端“一次并不意味着任何特定的实现特征（例如，应用程序是否在服务器、桌面或其他设备上执行）。

* 授权服务器(**authorization server**)

    在成功验证资源所有者身份并获得授权后，向客户端**发放访问令牌的服务器**。

**授权服务器**和**资源服务器**之间的交互超出了本规范的范围。
授权服务器可以是与资源服务器相同的服务器，也可以是单独的实体。
单个授权服务器可发出多个资源服务器接受的访问令牌。

### 1.2. Protocol Flow 协议流程

```text
     +--------+                               +---------------+
     |        |--(A)- Authorization Request ->|   Resource    |
     |        |                               |     Owner     |
     |        |<-(B)-- Authorization Grant ---|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(C)-- Authorization Grant -->| Authorization |
     | Client |                               |     Server    |
     |        |<-(D)----- Access Token -------|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------>|    Resource   |
     |        |                               |     Server    |
     |        |<-(F)--- Protected Resource ---|               |
     +--------+                               +---------------+

                     Figure 1: Abstract Protocol Flow _抽象协议流程_
```

图 1 所示的抽象 OAuth 2.0 流程描述了四个角色之间的交互，包括以下步骤：

* (A) **客户端**向**资源所有者**请求授权。授权请求可以直接向资源所有者提出（如图所示），也可以通过**授权服务器**作为中介间接提出。
* (B) **客户端**收到**授权许可**，它是**代表资源所有者授权的凭证**，使用本规范定义的四种许可类型之一或扩展许可类型表示。授权授予类型取决于客户机用于请求授权的方法和授权服务器支持的类型。
* (C) **客户端**通过对**授权服务器**进行**身份验证**并提交**授权许可**来**请求访问令牌**。
* (D) **授权服务器**对**客户端**进行身份验证并验证授权许可，如果有效，则签发访问令牌。
* (E) **客户端**向**资源服务器**请求受保护的资源，并通过出示访问令牌进行身份验证。
* (F) **资源服务器**验证访问令牌，如果有效，则为请求提供服务。

**客户端**从**资源所有者**处获取授权许可的首选方法（如步骤 `(A)` 和步骤 `(B)` 所示）是使用**授权服务器**作为中介，如第 4.1 节中的图 3 所示。

### 1.3. Authorization Grant 授权许可

**授权许可**是代表资源所有者**授权**（访问其受保护资源）的凭证，客户端使用它来获取访问令牌。
本规范定义了四种授权类型—— **授权码**(`authorization code`)、**隐式**(`implicit`)、**资源所有者密码凭证**(`resource owner password credentials`)、**客户端凭证**(`client credentials`) —— 以及一种用于定义其他类型的扩展机制

#### 1.3.1. Authorization Code 授权码

**授权码**是通过**授权服务器**作为**客户端**和**资源所有者**之间的**中介**获得的。
**客户端**不直接向资源所有者请求授权，而是将资源所有者引向**授权服务器**（通过 [RFC 2616] 中定义的用户代理），**授权服务器**再将资源所有者引导回客户端并提供**授权代码**。

在将资源所有者与授权代码一起发回客户端之前，授权服务器会对资源所有者进行**身份验证**并获得**授权**。
由于**资源所有者**只对**授权服务器**进行验证，因此不会与客户端共享资源凭据。

**授权代码**提供了一些重要的安全优势，如对客户端进行过验证的能力，以及直接向客户端传输访问令牌的能力，而无需通过资源所有者的用户代理，也不会将访问令牌暴露给其他人，包括资源所有者。

#### 1.3.2. Implicit 隐式

**隐式授权**是一种简化的授权代码流，针对使用 JavaScript 等脚本语言在浏览器中实施的客户端进行了优化。
在隐式流程中，不向客户端发放授权代码，而是直接向客户端发放访问令牌（作为资源所有者授权的结果）。
这种授权类型是隐式的，因为**没有签发中间凭证**（如授权码）（随后用于获取访问令牌）。

在隐式授予流程中签发访问令牌时，授权服务器**不会对客户端进行身份验证**。
在某些情况下，**客户端身份可通过用于向客户端发送访问令牌的 URI 进行验证**。
访问令牌可能会暴露给资源所有者或者其他可以访问资源所有者用户代理的应用程序。

隐式授予可提高某些客户端（如作为浏览器内应用程序实施的客户端）的响应速度和效率，因为它减少了获取访问令牌所需的往返次数。
不过，在使用隐式授权（如第 10.3 节和第 10.16 节所述）时，应权衡这种便利性与安全性之间的影响，尤其是当授权代码授予类型可用时。

#### 1.3.3. Resource Owner Password Credentials 资源所有者密码凭证

资源所有者密码凭证（即用户名和密码）可直接用作获取访问令牌的授权许可。
只有当资源所有者和客户机之间存在高度信任（例如客户机时设备操作系统或高权限应用程序的一部分），并且没有其他授权类型（如授权码）时，才可使用凭据。

尽管这种授权类型要求客户端直接访问资源所有者凭据，但资源所有者凭据只用于单次请求，并与访问令牌交换。
通过用**长期访问令牌**和**刷新令牌**交换凭证，这种授权类型可以使客户无需存储所有凭据以供将来使用。

#### 1.3.4. Client Credentials 客户端凭证

当授权范围仅限于**客户机控制下的受保护资源**或**先前与授权服务器安排的受保护资源**时，客户机凭证（或其他形式的客户机身份验证）可用作授权授予。
客户端凭证通常在客户端**代表自己**行事（客户端也是资源所有者）或根据先前与授权服务器安排的授权请求访问受保护资源时用作授权许可。

### 1.4. Access Token 访问令牌

访问令牌是用于访问受保护资源的凭证。
访问令牌是一个字符串，代表向客户端发出的授权。
该字符串通常**对客户端不透明**。
令牌代表特定的**访问范围**和期限，由资源所有者授予，并由资源服务器和授权服务器**强制执行**。

令牌可以表示用于**检索授权信息**的标识符，也可以**以可验证的方式自行包含授权信息**（即由某些数据和签名组成的令牌字符串）。
客户端要使用令牌，可能还需要额外的认证凭证，这超过了本规范的范围。

访问令牌提供了一个抽象层，用资源服务器能理解的单一令牌取代了不同的授权结构（如用户名和密码）。
通过这种抽象层，访问令牌的限制比用于获取访问令牌的授权许可更**严格**，资源服务器也无需了解各种身份验证方法。

根据资源服务器的安全要求，访问令牌可以有不同的格式、结构和使用方法（如加密属性）。
访问令牌属性和用于访问收保护资源的方法超出了本规范的范围，由 [RFC6750] 等配套规范定义。

### 1.5. Refresh Token 刷新令牌

刷新令牌是用于获取访问令牌的凭证。
刷新令牌由授权服务器发送给客户端，用于在**当前访问令牌失效或过期时获取新的访问令牌**，或**获取范围相同或更小的其他访问令牌**（访问令牌的有效期和权限可能比资源所有者授权的更短）。
授权服务器可自行决定是否发放刷新令牌。
如果授权服务器发送刷新令牌，则在发放访问令牌时将其包括在内（即图 1 中的步骤 (D)）。

刷新令牌是一个字符串，代表资源所有者授予客户端的授权。
该字符串通常对客户不透明。
令牌表示用于检索授权信息的标识符。
与访问令牌不同，刷新令牌仅供授权服务器使用，绝不会发送给资源服务器。

```text
  +--------+                                           +---------------+
  |        |--(A)------- Authorization Grant --------->|               |
  |        |                                           |               |
  |        |<-(B)----------- Access Token -------------|               |
  |        |               & Refresh Token             |               |
  |        |                                           |               |
  |        |                            +----------+   |               |
  |        |--(C)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(D)- Protected Resource --| Resource |   | Authorization |
  | Client |                            |  Server  |   |     Server    |
  |        |--(E)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(F)- Invalid Token Error -|          |   |               |
  |        |                            +----------+   |               |
  |        |                                           |               |
  |        |--(G)----------- Refresh Token ----------->|               |
  |        |                                           |               |
  |        |<-(H)----------- Access Token -------------|               |
  +--------+           & Optional Refresh Token        +---------------+

               Figure 2: Refreshing an Expired Access Token
```

图 2 所示的流程包括以下步骤：

* (A) 客户端向授权服务器验证身份并提交授权许可，从而申请访问令牌。
* (B) 授权服务器对客户端进行身份验证并验证授权许可，如果有效，则发出**访问令牌**和**刷新令牌**。
* (C) 客户端通过出示访问令牌向**资源服务器**发出受保护的资源请求。
* (D) **资源服务器**验证访问令牌，如果有效，则为请求提供服务。
* (E) 重复步骤 `(C)` 和 `(D)` ，直到访问令牌过期。如果客户机知道访问令牌已过期，则跳至步骤 `(G)` ；否则，客户机将提出另一个受保护资源请求。
* (F) 由于访问令牌无效，资源服务器**返回无效令牌错误**信息。
* (G) 客户端向授权服务器进行身份验证并提交**刷新令牌**，从而请求获得新的访问令牌。客户端验证要求基于客户端类型和授权服务器策略。
* (H) 授权服务器对客户进行身份验证并验证刷新令牌，如果有效，则**签发新的访问令牌**（可选择签发新的刷新令牌）。

步骤 (C)、(D)、(E)和(F)不属于本规范的范围，详见第 7 节。

### 1.6. TLS Version TLS 版本

在本规范使用传输层安全(TLS)时， TLS 的适当版本（或多个版本）会随着时间的推移而变化，这取决于广泛的部署情况和已知的安全漏洞。
在撰写本文时， TLS 1.2 版 [RFC5246] 是最新版本，但其部署基础非常有限，可能无法随时实施。
TLS 1.0 版 [RFC2246] 是部署最广泛的版本，将提供最广泛的互操作性。

实施方案还可以支持符合其安全要求的其他传输层安全机制。

### 1.7. HTTP Redirections HTTP 重定向

此规范广泛使用 HTTP 重定向，即**客户端**或**授权服务器****将资源所有者的用户代理指向另一个目的地**。
虽然本规范中的示例显示了 HTTP 302 状态代码的使用，但也允许通过用户代理使用任何其他方法来完成重定向，这些方法被视为实施细节。

### 1.8. Interoperability 互操作性

OAuth 2.0 提供了一个具有明确安全属性的丰富授权框架。
然而，作为一个包含许多可选组件的丰富且高度可扩展的框架，该规范本身可能会产生大量不可互操作的实现。

此外，此规范还**部分或全部未定义一些必要组件**（如**客户端注册**、**授权服务器功能**、**端点发现**）。
如果没有这些组件，客户端必须针对特定的授权服务器和资源服务器进行手动和专门的配置，才能实现互操作。

在设计该框架时，我们明确期望未来的工作能定义必要的规范性配置文件和扩展，以实现全面的网络规模互操作性。

### 1.9. Notational Conventions 符号约定

本规范中的关键词： **必须(MUST)**、**不得(MUST NOT)**、**必需(REQUIRED)**、**应(SHALL)**、**不应(SHALL NOT)**、**应该(SHOULD)**、**不应(SHOULD NOT)**、**推荐(RECOMMENDED)**、**可以(MAY)** 和 **可选(OPTIONAL)** 应按 [RFC2119] 中所述进行解释。

本规范使用 [RFC5234] 的 Augmented Backus-Naur Form(ABNF) 符号。
此外，规则 URI 引用包含在**统一资源标识符(URI)**：泛型语法 [RFC3986] 中。

某些与安全相关的术语应按照 [RFC4949] 中定义的含义来理解。
这些术语包括但不限于 **攻击(attack)**、**认证(authentication)**、**授权(authorization)**、**证书(certificate)**、**保密(confidentiality)**、**凭证(credential)**、**加密(encryption)**、**身份(identity)**、**(sign)**、**签名(signature)**、**(trust)**、**(validate)** 和 **验证(verify)**。

除非另有书名，否则所有协议参数名称和值区分大小写。

## 2. Client Registration 客户端注册

在启动协议之前，客户端要向服务器注册。
客户端向授权服务器的注册的方式超出了本规范的范围，但通常涉及终端用户与 HTML 注册表单的交互。

客户端**注册**不需要客户端与授权服务器直接的直接交互。
在**授权服务器**支持的情况下，注册可以依赖其他方式来建立**信任**并获取所需的**客户端属性**（如重定向 URI 、客户端类型）。
例如，注册可通过自我发布或第三方发布的断言来完成，或者由授权服务器使用可信信道执行客户端发现来完成。

注册客户端时，客户端开发者**必须**：

* 指定第 2.1 节所述的的**客户机类型**，
* 提供第 3.1.2 节所述的**客户端重定向 URI**， 以及
* 包括授权**服务器要求的任何其他信息**（例如，应用程序名称、网站、描述、徽标图像、接受的法律条款）。

### 2.1. Client Types 客户端类型

OAuth 根据客户端向与授权服务器进行**安全验证的能力**（即客户端凭证的保密能力）定义了两种客户端类型：

* 保命型

    能对其凭据保密的客户端（例如，在安全服务器上实施的客户端，对客户端凭证的访问受限），或能使用其他方式进行安全客户端身份验证的客户端。
* 公开型

    无法对其凭证保密的客户端（例如，在资源所有者使用的设备上执行的客户端，如安装的本地应用程序或基于浏览器的应用程序），以及无法通过任何其他方式进行安全客户端身份验证的客户端。

客户端类型的指定基于授权服务器对**安全身份验证的定义**及其**可接受的客户端凭证暴露级别**。
授权服务器不应假设客户端类型。

客户端可以作为一组分布式组件来实现，每个组件都有不同的客户端类型和安全环境（例如，分布式客户端既有基于服务器的机密组件也有基于公共浏览器的组件）。
如果授权服务器不为此类客户端提供支持，或者未提供有关其注册的指导，则客户端应将每个组件注册为单独的客户端。

本规范是围绕以下客户端配置文件设计的：

* 网络应用程序(web application)

    网络应用程序是在网络服务器上运行的机密客户端。
    资源所有者通过在资源所有者使用的设备上的用户代理中呈现的 HTML 用户界面访问客户端。
    **客户端凭证**以及向客户端发出的任何访问**令牌**都存储在网络服务器上，不会向资源所有者公开，资源所有者也无法访问。

* 基于用户代理的应用程序(user-agent-based application)

    基于用户代理的应用程序是一种**公共客户端**，其中客户端代码从网络服务器下载，并在资源所有者使用的设备上的用户代理（如网络浏览器）中执行。
    协议数据和凭证很容易被资源所有者访问（通常是可见的）。
    由于此类应用程序位于用户代理内，因此在请求授权时可无缝使用用户代理功能。

* 原生应用程序(native application)

    原生应用程序实在资源所有者使用的设备上安装和执行的公共客户端。
    资源所有者可访问协议数据和凭证。
    假定应用程序中包含的任何客户端身份凭证都能被提取出来。
    另一方面，动态签发的凭证（如访问令牌或刷新零阿皮）可以获得可接受级别的保护。
    至少，这些凭证受到保护，不会被用于与应用程序交互的恶意服务器窃取。
    在某些平台上，这些凭证还可能受到保护，不会受到驻留在同一设备上的其他应用程序的攻击。

### 2.2. Client Identifier 客户端标识符

授权服务器向已注册的客户端颁发**客户端标识符**--表示客户端提供的注册信息的唯一字符串。
客户端标识符不是机密；它向资源所有者公开，不得单独用于客户端身份验证。
客户端标识符对于授权服务器时唯一的。

此规范未定义客户端标识符字符串大小。
客户端应避免对标识符大小做出假设。
**授权服务器**应记录它颁发的任何**标识符的大小**。

### 2.3. Client Authentication 客户端身份验证

如果客户端类型是**机密**的，则客户端和授权服务器将创建适合授权服务器安全要求的客户端**身份验证方法**。
授权服务器可以接受满足其安全要求的任何形式的客户端身份验证。

机密客户端通常颁发（或创建）一组用于向授权服务器进行身份验证的客户端凭证（例如，密码、公钥/私钥对）。

授权服务器可以与公共客户端建立客户身份验证方法。
但是，授权服务器不得依赖公开客户端身份验证来标识客户端。

客户端不得在每个请求中使用多个身份验证方法。

#### 2.3.1. Client Password 客户端密码

拥有客户端密码的客户端可以使用 [RFC2617] 中定义的 HTTP 基本身份验证方案与授权服务器进行身份验证。
客户端标识符使用附录 B 中的 `application/x-www-form-urlencoded` 编码算法进行编码，编码值用作用户名；客户端密码使用相同的算法进行编码并用作密码。
授权服务器必须支持 HTTP 基本身份验证方案，用于对客户端密码进行身份验证。

举例说明（带有额外的换行符仅用于显示目的）：

`Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3`

或者，授权服务器可以支持使用以下参数将**客户凭证**包含在请求正文中：

* `client_id`

    **必须**。在第 2.2 节所述的注册过程中发送给客户端的客户端标识符。

* `client_secret`

    **必须**。客户的密钥(secret)。如果客户端密钥未空字符串，客户端可以省略该参数。

不推荐使用两个参数在请求正文中包含客户凭据。
并且应仅限于无法直接使用 HTTP 基本身份验证方案（或其他基于密码的 HTTP 身份验证方案）的客户端。
参数只能在请求主体中传输，并且不得包含在请求 URI 中。

例如，使用正文参数刷新访问令牌（第 6 节）的请求（为便于显示，多加了换行符）：

```http request
POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
&client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw
```

使用密码验证发送请求时，授权服务器必须使用第 1.6 节所述的 TLS 。

由于这种客户端身份验证方法涉及密码，因此授权服务器必须保护使用这种方法的任何端点免受暴力攻击。

#### 2.3.2. Other Authentication Methods 其他身份验证方法

授权服务器可以支持任何符合其安全要求的合适 HTTP 身份验证方案。
使用其他身份验证方法时，授权服务器必须定义客户端标识符（注册记录）和身份验证方案之间的映射。

### 2.4. Unregistered Clients 未注册客户端

此规范不排除使用未注册的客户端。
但是，此类客户端的使用超出了本规范的范围，需要额外的安全分析和审查其互操作性影响。

## 3. Protocol Endpoints 协议端点

授权过程使用两个授权服务器端点（HTTP 资源）：

* 授权端点(Authorization endpoint) - 
* 令牌端点(Token endpoint)

### 3.1. Authorization Endpoints
#### 3.1.1. Response Type
#### 3.1.2. Redirection Endpoint
