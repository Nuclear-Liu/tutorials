# 并发标记算法

> 难点：**在标记对象的过程中，对象引用关系正在发生改变**。

## 三色标记法

* 黑色：自身和成员均已标记完成
* 灰色：自身被标记，成员变量未被标记
* 白色：未被标记的对象

### 漏标

发生的充分必要条件：

* 并发标记过程中，黑色指向了白色，灰色对白色的引用消失，会导致**漏标**；

> 在 remark 过程中，黑色指向了白色，如果不对黑色重新扫描，则会**漏标**会把白色对象当作没有新引用指向从而回收掉；
>
> 并发标记过程中， Mutator 删除了所有从灰色到白色的引用，会产生漏标此时白色对象应该被回收。

解决方式：
1. incremental update : 增量更新，**关注引用的增加**，把**黑色**重新标记为**灰色**，下次重新扫描属性；
2. STAB snapshot at the beginning : 关注引用的删除，当**灰色**到**白色**引用消失时，要把这个**引用**推到 GC 的堆栈，保证白色对象能够被 GC 扫描到；

> G1 为什么使用 STAB 而不是 incurmental update
> 
> 避免要重新扫描黑色对象对白色的引用；
> G1 STAB 配合 RSet(RSet 记录了对象前 Region 的引用)效率更高；

> RSet 与 赋值的效率
> 
> 由于 RSet 的存在，每次给对象赋值引用，需要做一些额外的操作（在RSet中做一些额外的记录）；
> 所做的额外的操作在GC中被称为写屏障。

