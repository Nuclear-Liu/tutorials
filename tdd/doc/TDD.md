# 最佳实践

* `Test` 作为类对应的测试类的名称**后缀**， `Test` 作为对应测试方法的**前缀**
* 对还**没有实现**的测试代码抛出一个**异常**(例如： `RuntimeException` )
* 测试的要点是：**一次只能单元测试一个对象**
    
  > 要创建一个单元测试，需要两种类型的对象：
  > * 要测试的**领域对象(Domain Object)**
  > * 用来与被测试对象交互的**测试对象(Test Object)**

* 选择有意义的测试方法名称
* 在 `assert` 调用中解释失败的原因

  > 使用了 JUnit 的任何 `assert*` 方法,确保自己使用第一个参数为 `String` 类型的那个签名.
  > 这个参数可以提供一个有意义的文本描述,在断言描述失败时 JUnit 的 test runner 就会显示这个描述.

* 一个单元测试等于一个 `@Test` 方法

  > 不要试图把多个测试塞进一个方法. 
  > 在测试中编写的逻辑更多,测试失败的可能性就越大,要进行调试的可能性就越大.
  > 最终坠入不得不为你的测试编写测试的深渊.
   
  > **唯一可以接受不使用 `assert` 调用的情况是当抛出一个异常来指出一个错误条件时.**

  > 每一个测试方法必须尽可能地简洁和目的明确.
  > Junit 提供了 `@Before` `@After` `@BeforeClass` `@AfterClass` 注解,你可以在多个测试之间共享 fixture ,而不必把测试方法组合起来.

* 测试任何可能失败的事物

  > 单元测试有助于明确你的方法遵守与其他方法的 API 契约.
  > 如果锲约仅仅要求其他组件遵守,而没有对你的方法提出什么约束,那么就可能没有什么有意义的行为值得测试.
  > 如果方法以任何方式**改变了参数值或者字段值**,那么这个方法就在提供独特的行为,就需要测试.
  
  > 这个方法并不仅仅是个中间人--它具有自己行为的方法,未来的改变可能会破坏它的行为.
  > 如果一个方法被改变了,变的不在简单,就应当为这个方法增加一个测试.但在改变之前则不需要增加.
  
  > JUnit FAQ: "一般的观点是这样的:如果它自身不可能出错,那么它就太简单了,简单得无法出错."
  > 这也是极限编程所持有的观点:"不要过早添加功能".

* 让测试改善代码

  > 一个测试用例就是一位你的代码的用户.
  > 只有在使用代码时才能发现代码中的缺点.
  > **应当根据测试时发现的问题重构代码,使其更加易于使用.**

* 测试类作为测试用例类的内部类