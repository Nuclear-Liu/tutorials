# `@SneakyThrows`

## Overview


`@SneakyThrows` can be used to sneakily throw checked exceptions without actually declaring this in your method's `throws` clause. 
This somewhat contentious ability should be used carefully, of course. 
The code generated by lombok will not ignore, wrap, replace, or otherwise modify the thrown checked exception; it simply fakes out the compiler. 
On the JVM (class file) level, all exceptions, checked or not, can be thrown regardless of the `throws` clause of your methods, which is why this works.


`@SneakyThrows` 可用于偷偷地抛出已检查的异常，而无需在方法的 `throws` 子句中实际声明。
当然，这种有点争议的能力应该谨慎使用。
lombok 生成的代码不会忽略、包装、替换或以其他方式修改抛出的检查异常；它只是伪造了编译器。
在 JVM（类文件）级别，无论您的方法的 `throws` 子句如何，所有异常，无论是否检查，都可以抛出，这就是为什么它有效。


Common use cases for when you want to opt out of the checked exception mechanism center around 2 situations:


当您想要选择退出已检查异常机制时的常见用例围绕 2 种情况：


* A needlessly strict interface, such as `Runnable` - whatever exception propagates out of your `run()` method, checked or not, it will be passed to the `Thread`'s unhandled exception handler. 
  Catching a checked exception and wrapping it in some sort of `RuntimeException` is only obscuring the real cause of the issue.
* An 'impossible' exception. 
  For example, `new String(someByteArray, "UTF-8");` declares that it can throw an `UnsupportedEncodingException` but according to the JVM specification, UTF-8 must always be available. 
  An `UnsupportedEncodingException` here is about as likely as a `ClassNotFoundError` when you use a `String` object, and you don't catch those either!


* 一个不必要的严格接口，例如 `Runnable` - 无论从你的 `run()` 方法传播出的异常，无论是否检查，它都会被传递给 `Thread` 的未处理异常处理程序。
  捕获已检查的异常并将其包装在某种“RuntimeException”中只会掩盖问题的真正原因。
* 一个“不可能”的例外。
  例如， `new String(someByteArray, "UTF-8");` 声明它可以抛出一个 `UnsupportedEncodingException` ，但根据 JVM 规范，UTF-8 必须始终可用。
  当你使用一个 `String` 对象时，这里的 `UnsupportedEncodingException` 和 `ClassNotFoundError` 的可能性差不多，而且你也没有捕捉到它们！


Being constrained by needlessly strict interfaces is particularly common when using lambda syntax (`arg -> action`); however, lambdas cannot be annotated, which means it is not so easy to use `@SneakyThrows` in combination with lambdas.


在使用 lambda 语法（`arg -> action`）时，受到不必要的严格接口的约束尤为常见；然而，lambdas 不能被注释，这意味着将 `@SneakyThrows` 与 lambdas 结合使用并不是那么容易。


Be aware that it is impossible to `catch` sneakily thrown checked types directly, as javac will not let you write a `catch` block for an exception type that no method call in the try body declares as thrown. 
This problem is not relevant in either of the use cases listed above, so let this serve as a warning that you should not use the `@SneakyThrows` mechanism without some deliberation!


请注意，不可能直接`catch` 偷偷抛出的已检查类型，因为 javac 不会让您为 try 主体中没有方法调用声明为抛出的异常类型编写 `catch` 块。
这个问题在上面列出的任何一个用例中都不相关，所以让它作为一个警告，你不应该在未经深思熟虑的情况下使用 `@SneakyThrows` 机制！


You can pass any number of exceptions to the `@SneakyThrows` annotation. 
If you pass no exceptions, you may throw any exception sneakily.


您可以将任意数量的异常传递给 `@SneakyThrows` 注释。
如果你没有通过异常，你可以偷偷地抛出任何异常
