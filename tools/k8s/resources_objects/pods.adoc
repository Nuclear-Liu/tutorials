= pod-tmp
:toc: left
:toclevels: 5
:toc-title: 目录

== Pods 容器集

=== Pod 引入

有一些容器关系紧密，必须在一起工作， Pod 将多个容器封装到一个**部署单元**中进行调度，从而一起部署和管理。

==== 案例

===== 案例1. 日志收集

[plantuml, format="svg" id="collection-log"]
----
@startuml

rectangle "Pod" #B1DDF0 {
component app #F8CECC
file logs
component filebeat #BAC8D3
}

component LoggingServer

app -> logs :write
logs -> filebeat :read
filebeat -> LoggingServer
@enduml
----

对服务模块稳定运行了一段时间，日志记录在某个目录下；希望将日志收集到统一的日志处理服务器上。

通过 Pod 的方式，通过简单的编排，在保持原有服务逻辑、部署方式不变的情况下，实现对日志收集。

===== 案例2. 访问容器数据：ssh/ftp

[plantuml, format="svg" id="remote-access"]
----
@startuml

rectangle "Pod" #B1DDF0 {
component app #F8CECC
component "ssh/ftp" #BAC8D3
}

app <-> "ssh/ftp"

@enduml
----

一般镜像并没有安装 sshd 等服务，不方便进入容器进行配置、修改、调试等。

通过 Pod 的方式，可以将一个现有镜像和一个 ssh/ftp 镜像进行编排，获得操作容器内数据的能力。

===== 案例3. 适配不同 IaaS 平台

[plantuml, format="svg" id="iaas-adaptor"]
----
@startuml

rectangle "Pod" #B1DDF0 {
component agent #F8CECC
interface localhost
component "adapter" #BAC8D3
}

cloud aws
cloud aliyun

agent - localhost
localhost - adapter
"adapter" <-> aws
"adapter" <-> aliyun
@enduml
----

比如开发了一个节点管理 agent 程序，这个 agent 需要读取当前部署环境的一些信息。

通过 Pod 编排运行一个适配各平台的服务，用来获取不同平台的相关信息，在不改变 agent 逻辑情况下，通过服务组合适配不同平台。

===== 案例4. 提供软件发行版本仓库

[plantuml, format="svg" id="sync-mirrors"]
----
@startuml

rectangle "Pod" #B1DDF0 {
component nginx #F8CECC
file pkg
component "sync" #BAC8D3
}

cloud mirrors

nginx <- pkg :read
pkg <- "sync" :write
"sync" <- mirrors :pull
@enduml
----

Nginx 容器用来发布软件，另一个容器专门负责从源仓库同步。
通过 Pod 将两个容器编排在一起提供软件仓库服务。

==== Pod 共享网络

在 Kubernetes 中， Pod 的网络共享和 Docker 的网络共享实现方式一致(即：**link** 方式)。

在启动 Pod 时，**首先**启动 **``pause``** 容器，将后续所有容器都 ``--link`` 到创建的 ``pause`` 容器，实现网络共享。

[plantuml, format="svg" id="network"]
----
@startuml

rectangle "Pod" #B1DDF0 {
component pause
component app #F8CECC
component db #BAC8D3
}

app --> pause :--link=pause
db --> pause :--link=pause
@enduml
----

* Pod 内共享网络的容器可以**直接**通过 ``localhost`` 相互访问
* Pod 内共享网络的容器不允许使用相同的**端口号**

==== Pod 共享存储

默认情况下容器间的文件系统是相互隔离的；
要实现文件共享，则需要在 Pod 层面**声明** ``volume`` 卷，然后在需要共享的容器中声明 ``VolumeMounts`` **挂载**文件系统，从而实现 Pod 内容器间文件共享。

[plantuml, format="svg" id="volume"]
----
@startuml

rectangle "Pod" #B1DDF0 {
component "container-m" #F8CECC
component "contianer-n" #BAC8D3
file volumes
}

"container-m" -- volumes :r/w
"contianer-n" -- volumes :r/w
@enduml
----

=== Pod 管理方式

==== 自主式管理 Pod

在 Kubernetes 中，部署 Pod 时，基本上都是使用控制器管理；
直接定义的 Pod 资源属于自主式管理 Pod ，特点：

* 如果删除自主管理的 Pod 将不会自动被拉起新的 Pod
* 如果自主管理的 Pod 所在的节点需要维护，节点将会被驱逐，此时自主式 Pod 随节点驱逐被删除，并且节点重新加入集群不会重建
* 如果自主管理的 Pod 期望部署多个副本并维持副本数量则需要认为参与，操作繁琐

创建自主管理 Pod 的方式：

*  通过 ``kubectl run`` 生成
+
[source,shell]
----
kubectl run pod [pod-name] --image=[image-name] --dry-run=client -o yaml
# kubectl run pod nginx --image=nginx --dry-run=client -o yaml
----

* 通过编写资源文件创建

删除 Pod 将会彻底删除:
[source,shell]
----
kubectl delete pod [pod-name]
# or
kubeclt delete -f [pod-yaml]
----

[TIP]
====
* 驱逐节点
+
[source,shell]
----
kubectl drain [node-hostname] --ignore-deamonsets --force
----

* 解除节点驱逐
+
[source,shell]
----
kubectl uncordon [node-hostname]
----
====

自主管理 Demo 案例：
[source,yaml]
----
include::../yaml/demo-pod-mult-c.yaml[]
----

==== 控制器管理 Pod

通常情况下 Kubernetes 使用更高级的控制器(``Controller``)来管理 Pod 实例。
Controller 可以创建和管理多个 Pod ， 提供**副本管理**、**滚动升级**和集群级别的**自愈能力**。

[plantuml, format="svg" id="controller-pod"]
----
@startuml

rectangle DaemonSet
rectangle Deployment
rectangle ReplicaSet
rectangle StatefulSet
rectangle CronJob
rectangle Job

rectangle PA #B1D000 {
rectangle HPA
rectangle VPA
}

rectangle "Pod" #B1DDF0 {
component "container" #F8CECC
}

Deployment -- ReplicaSet
CronJob -- Job
DaemonSet --- "Pod"
StatefulSet --- "Pod"
ReplicaSet --- "Pod"
Job --- "Pod"
HPA -- "Pod"
VPA -- "Pod"
@enduml
----

=== Pod 声明周期

==== Pod 状态阶段

[plantuml, format="svg" id="state-pod"]
----
@startuml

state Pending
state Running
state Succeeded
state Failed
state Unknown

[*] -> Pending
Pending --> Running
Running --> Failed
Failed --> Running
Running --> Succeeded
Succeeded --> [*]
@enduml
----
